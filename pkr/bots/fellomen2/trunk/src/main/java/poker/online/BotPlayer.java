/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/ package poker.online;import java.util.*;import java.lang.reflect.*;import poker.util.*;import poker.online.*;import poker.*;import poker.util.Reporter;/** * BotPlayer handles all of the network communication needed * to play on the poker server. Simply implement the Player * interface, and give the server details to BotPlayer, * and your program will be able to play online. * * @author Aaron Davidson * @version 1.1.0 */public class BotPlayer implements Runnable {	private volatile boolean inGame = false;	private volatile boolean quit = false;	/* game info */	private GameInfo gInfo; 	private String botName; 	private int numPlayers = 0;	private int POS = 0;	private int bet_size = 0;	private int toAct, nextToAct;	private Preferences prefs;		private volatile Vector msgs = new Vector();	private Client cp;	Player bot;		/**	 * Constructor.	 * @param p An implementation of a Player.	 * @param server the address of the server	 * @param port the server port number     * @param nick the player's user name     * @param pwd the player's password     */	public BotPlayer(String pfile) {		installShutDownHook();		this.prefs = new Preferences(pfile);				String server = prefs.getPreference("SERVER");		int port = prefs.getIntPreference("PORT");						String nick = prefs.getPreference("NICKNAME");		String pwd = prefs.getPreference("PASSWORD");		String ports = prefs.getPreference("ROOMS");			bot = Player.loadPlayer(pfile);		botName = nick;				// log onto the server		while (!quit) {			if (!inGame) {				connectToServer(server, port, nick, pwd);				}			try { Thread.currentThread().sleep(prefs.getIntPreference("SLEEP") + 1000); 			} catch (InterruptedException e) {}			}	}			private void installShutDownHook() {		// this big try block is meant to install a shutDownHook, but only 		// works in jre1.3, so reflection is used to insure the method		// exists. Otherwise, we could just use:		//	   Runtime.getRuntime().addShutdownHook(new Thread(this, "SHUTDOWN"));		try {			Class[] param = {Thread.currentThread().getClass()};			Method m = Runtime.getRuntime().getClass().getMethod("addShutdownHook", param);			Object [] mparam = {new Thread(this, "SHUTDOWN")};			m.invoke(Runtime.getRuntime(), mparam);			println("Hook installed...");			} catch (NoSuchMethodException nsme) {			println("Can't install shutdown hook...");			} catch (SecurityException se) {		} catch (InvocationTargetException ite) {		} catch (IllegalAccessException ite) {}	}		/**	 * Constructor.	 * @param p An implementation of a Player.	 * @param server the address of the server	 * @param port the server port number     * @param nick the player's user name     * @param pwd the player's password     */	public BotPlayer(Player p, String server, int port, String nick, String pwd) {		bot = p;		botName = nick;		installShutDownHook();		// log onto the server		connectToServer(server, port, nick, pwd);		}				/** 	 * Connect to the server	 * @param url the server domain name or IP address	 * @param port the server port	 * @param uname our user name	 * @param pwd our password for the server	 */	private void connectToServer(String url, int port, String uname, String pwd) {			println("Connecting to " + url+ ":"+port+"...");		cp = new Client(url, port);   		if (cp.connect()) {   			ByteArray d = new ByteArray();   			println("Connected...");	        d.append(uname);   	        d.append(pwd);   	        d.append(1);   	        d.append("BotPlayer");   	        			int id = Message.writeMessage(PokerConsts.JOIN_GAME, d, cp);			println("Authenticating...");			if (id == -1) {				println("Connection Failure.\n");			} else {				Message msg = new Message();				id = msg.readMessage(cp);				if (id == PokerConsts.GOODPASS) {					println("Authorization Granted.");					inGame = true;					println("Waiting for new game to start...\n   (this may take a minute or two).");					Thread t = new Thread(this);					t.start();				} else if (id == PokerConsts.BADPASS) {					println("Authorization Failed.");					println("a) Your password or login may be incorrect.");					println("b) Someone by that name is already in the game.");											// bad password				}				}		} else {			println("Could not connect to server.");			println("a) You cannot play from behind a firewall that blocks non-http ports.");			println("b) Our poker server may be temporarily down. Try back later.");            // could not connect to server.   		}	}	public void run() {		if (Thread.currentThread().getName().equals("SHUTDOWN")) 			shutdown();		else			playGame();	}			private void playGame() {		ByteArray d;		Hand bd,h;		boolean needCards = false;		int amnt,i,who;    	Message msg = new Message();		while (cp != null) {			if (inGame && msgs.size() > 0) {				d = (ByteArray)msgs.firstElement();				msgs.removeElementAt(0);				if (Message.writeMessage(d.getInt(0), d.getByteArray(4,d.size()-4), cp) == -1) {					if (cp != null) cp.close(); cp = null;					if (inGame) quitGame();				}			}						if (cp.unread()) {				int id = msg.readMessage(cp);				if (id == -1) {					if (cp != null) cp.close(); cp = null;					if (inGame) quitGame();				}				ByteArray br = msg.getMessageData();								switch (id) {					case PokerConsts.GOODBYE:						println("GOODBYE");						if (cp != null)							cp.close(); cp = null;						if (inGame)							quitGame();						break;												case PokerConsts.CHATTER:							String cht = br.readString();							println(cht);							doChatter(cht);							break;						case PokerConsts.INFORMATION:							println(br.readString());							break;						case PokerConsts.PING:							Message.writeMessage(PokerConsts.PONG, cp);							println("[PING]");							break;						case PokerConsts.START_NEW_GAME:							gInfo = new GameInfo();							gInfo.setBetMultiplier(br.readInt()/2);							numPlayers = br.readInt();							int button = br.readInt();							POS = br.readInt();							int gID = br.readInt();							for (i=0;i<numPlayers;i++) {																String name = br.readString();								int bankroll = br.readInt();								int face = br.readInt();								gInfo.addPlayer(name,gInfo.LOG_DIR+name.toLowerCase()+".dat");								gInfo.getPlayerInfo(name).setBankRoll(bankroll);							}							gInfo.startNewGame(gID);							gInfo.setButton(button);							printTable();							needCards = true;							break;													case PokerConsts.HOLE_CARDS:							int p = br.readInt();							h = new Hand(br.readString());							gInfo.getPlayerInfo(p).revealHand(h.getCard(1), h.getCard(2));							println("     " + gInfo.getPlayerName(p) + ":  " + h.toString() );							if (p == POS && needCards) {								bot.newGame(gInfo, h.getCard(1), h.getCard(2), POS);								needCards = false;							}							break;													case PokerConsts.NEW_STAGE:								int code = br.readInt();							h = new Hand(br.readString());							toAct = gInfo.getNumActivePlayers();														if (code == PokerConsts.PREFLOP) {								//println(" * PREFLOP\n");								updatePlayers(GameInfo.U_STAGE, Holdem.PREFLOP);							} else if (code == PokerConsts.FLOP) {													gInfo.flop(h.getCard(1),h.getCard(2),h.getCard(3));	  								updatePlayers(GameInfo.U_STAGE, Holdem.FLOP);															//println("\n * FLOP:  " + h.toString());					   	} else if (code == PokerConsts.TURN) {					   		gInfo.turn(h.getCard(4));	  					   		updatePlayers(GameInfo.U_STAGE, Holdem.TURN);								//println("\n * TURN:  " + h.toString());															} else if (code == PokerConsts.RIVER) {								gInfo.river(h.getCard(5));	  					   		updatePlayers(GameInfo.U_STAGE, Holdem.RIVER);								//println("\n * RIVER:  " + h.toString());																	}							gInfo.setCurrentPlayerPosition(gInfo.getButton());							selectNextToAct();							break;													case PokerConsts.NEXT_TO_ACT:  							nextToAct = br.readInt();							//println("   "+nextToAct+" " + gInfo.getPlayerName(nextToAct) + "$"+br.readInt());							if (nextToAct != gInfo.getCurrentPlayerPosition()) {							//	gInfo.setCurrentPlayerPosition(nextToAct);								println("!!!!!!!!!!!!!! OUT OF SYNC");							}							break;						case PokerConsts.BLIND:							who = br.readInt();							if (who != nextToAct) break;							amnt = br.readInt();							//println(gInfo.getPlayerName(who) + " blinds $" + amnt);											if (amnt == bet_size) {								gInfo.bigBlind();								updatePlayers(GameInfo.U_BBLIND, gInfo.getCurrentPlayerPosition());							} else {								gInfo.smallBlind();								updatePlayers(GameInfo.U_SBLIND, gInfo.getCurrentPlayerPosition());							}														selectNextToAct();							break;													case PokerConsts.FOLD:							who = br.readInt();							if (who != nextToAct) break;							toAct--;							//println(gInfo.getPlayerName(who) + " folds");							gInfo.fold();							updatePlayers(GameInfo.U_FOLD, who);		   					selectNextToAct();							break;						case PokerConsts.CALL:							who = br.readInt();							if (who != nextToAct) break;							amnt = br.readInt();							toAct--;							gInfo.call();							if (amnt == 0) {								//println(gInfo.getPlayerName(who) + " checks");								updatePlayers(GameInfo.U_CHECK, who);																} else {								//println(gInfo.getPlayerName(who) + " calls $" + amnt);								updatePlayers(GameInfo.U_CALL, who);							}							selectNextToAct();							break;											case PokerConsts.RAISE:							who = br.readInt();							if (who != nextToAct) break;							amnt = br.readInt();							toAct = gInfo.getNumActivePlayers()-1;							if (gInfo.raise()) {								//println(gInfo.getPlayerName(who) + " bets $" + gInfo.getBetSize());								updatePlayers(GameInfo.U_BET, who);													} else {								//println(gInfo.getPlayerName(who) + " raises $" + gInfo.getBetSize());								updatePlayers(GameInfo.U_RAISE, who);							}							selectNextToAct();							break;												case PokerConsts.WINNERS:							int numwin = br.readInt();							for (i=0;i<numwin;i++) {							 	who = br.readInt();								amnt = br.readInt();								gInfo.getPlayerInfo(who).win(amnt);							}							updatePlayers(GameInfo.U_GAME_OVER, 0);							gInfo.gameOver();							break;															default:						break;				}			} else {				try { Thread.currentThread().sleep(50); 				} catch (InterruptedException e) {}					Thread.currentThread().yield();			}		}   }  	private void selectNextToAct() {	 	gInfo.advanceCurrentPlayer();		nextToAct = gInfo.getCurrentPlayerPosition(); /*******/		//println("   " +toAct + " (toact = " + gInfo.getCurrentPlayerName() + ")");	 	if (gInfo.getCurrentPlayerPosition() == POS && toAct > 0) {			if (gInfo.getStage() == Holdem.PREFLOP) {				if (gInfo.getPot() <= gInfo.getBetSize()) return;			}			// println("\n[GET ACTION]");	 		 int a = bot.action();	  		 ByteArray d = new ByteArray();			 d.append(PokerConsts.ACTION);          d.append(a);          msgs.addElement(d);	 	} 	} 	 	protected void updatePlayers(int action, int code) {		bot.update(action, code);	}   	public final void println(String str) { 	 	System.out.println(str);   }	public void quitGame() {		inGame = false;		println("You are now logged off.");		if (cp != null)			Message.writeMessage(PokerConsts.QUIT_GAME, cp);		if (cp != null)						cp.close();		cp = null;		}	public void printTable() {		println("");		println("\n--- NEW GAME --- " + gInfo.getID() + " ---");		for (int i=0;i<gInfo.getNumPlayers();i++) 			println((i==gInfo.getButton() ? ("B> ") : (" > ")) + Reporter.pad(gInfo.getPlayerName(i), 14) + " " + gInfo.getPlayerInfo(i).getBankRoll() );		println("-----------------------");	}	public void shutdown() {		quit = true;		println("Logging Off...");        if (inGame) quitGame();   }   	protected void doChatter(String s) {		String who = "Dude";		String res = Reporter.loadExec("./scripts/chat.pl respond "+ who + " '" + escape(s) +"'");		if (res != null) {			if (res.length() > 1) {								chat(res);			}		}	}		private String escape(String s) {		char[] cs = new char[s.length()];		for (int i=0;i<s.length();i++) {			char v = s.charAt(i);			if (v >= 32 && v <= 126) {				if (v == '"') v = ' ';				if (v == '\'') v = ' ';			} else v = ' ';			cs[i] = v;		}		return new String(cs);	}	protected void chat(String s) {			}	/**	 *	 Main entry point. Create a player and log onto the server through     *  a BotPlayer.     */	static public void main(String[] args) {		new BotPlayer(Player.loadPlayer(args[0]), 				args[1], Integer.decode(args[2]).intValue(), args[3], args[4]);	}	}