/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker.util;import java.io.*;import java.util.*;import java.lang.Runtime;/** * Handles reporting messages to stdout or stderr, and logging messages to files. * Defaults to printing output to stderr. * * @author  Aaron Davidson * @version 1.3.5 */public class Reporter {	private boolean console = true;	private Vector listeners = new Vector();	private boolean active = true;	private boolean logOn;	private boolean debug = false;	private String logfile;	private volatile RandomAccessFile lf;	private static BufferedReader reader;	private static Reporter gRep = null;	public static synchronized Reporter getReporter() {		if (gRep == null) {			gRep = new Reporter();		} 		return gRep;	}	public Reporter() {		// assumes reporter has already been statically initialized	}	public Reporter(String logfile) {		setLogFile(logfile);	}		public synchronized void setLogFile(String logfile) {		//System.out.println("SETTING REPORTS TO: " + logfile);		logOn = (logfile != null);		this.logfile = logfile;		try {			if (lf != null) {				lf.close();			}			if (logOn) {	   			lf = new RandomAccessFile(logfile,"rw");					lf.seek(lf.length());			}  		} catch (IOException ie) { ie.printStackTrace(); }	}		static {		reader = new BufferedReader(new InputStreamReader(System.in));	}	public void setDebug(boolean on) {		debug = on;	}	public void setActive(boolean t) {		active = t;	}	public void debug(String s) {		if (debug) report(s);	}	public void debugb(String s) {		if (debug) reportb(s);	} 	public void addReportListener(ReportListener rl) {   		listeners.addElement(rl);   	} 	public void removeReportListener(ReportListener rl) {   		listeners.removeElement(rl);   	}		private void callListeners(String s) {		for (int i=0;i<listeners.size();i++)      	((ReportListener)listeners.elementAt(i)).reportMessage(s);	}	/**	 * Non-negative value indicating priority  threshold for reporting messages.	 */	public int	level = 0;	/**	 * disable the output to console	 */	public void consoleOff() {		console = false;	}	/**	 * Set the output to console	 */	public void consoleOn() {		console = true;	}	/**	 * Print a message to the current output stream.	 * @param s the string to print.	 */	public synchronized void println(String s) {		report(s);	}		/**	 * Print a message to the current output stream.	 * Does not print a line feed at the end of the string.	 * @param s the string to print.	 */	public synchronized void print(String s) {		reportb(s);	}	/**	 * Print a message to the current output stream.	 * @param s the string to print.	 */	public synchronized void report(String s) {		if (active) {			if (console) System.err.println(s);			if (logOn) appendLog(s+"\n");			callListeners(s+"\n");		}	}	/**	 * Print a message to the current output stream.	 * Does not print a line feed at the end of the string.	 * @param s the string to print.	 */	public synchronized void reportb(String s) {		if (active) {			if (console) System.err.print(s);			if (logOn) appendLog(s);			callListeners(s);		}	}	/**	 * Print a message to the current output stream if the priority is high enough.  	 * Note: 0 is the highest priority. Larger numbers are of lower priority.	 * @param s the string to print.	 * @param priority the priority of this message	 */	public synchronized void report(String s, int priority) {		if (active) {			if (priority > level) return;			if (console) System.err.println(s);			if (logOn) appendLog(s+"\n");			callListeners(s);		}	}	/**		 * Logs a message to a file.	 * @param s the message to log.	 * @param file the name of the file to log to.	 */	public synchronized static void log(String s, String file) {		try {         	RandomAccessFile f = new RandomAccessFile(file,"rw");			f.seek(f.length());			f.writeBytes(s);       	 	f.close();        } catch (IOException ie) { ie.printStackTrace(); }	}	/**		 * Logs a message to a file.	 * @param s the message to log.	 */	public synchronized void appendLog(String s) {		if (logfile == null) return;		if (active) {			if (lf == null) {				try {        	      lf = new RandomAccessFile(logfile,"rw");					lf.seek(lf.length());        		} catch (IOException ie) { 					System.err.println("APPENDLOG ERROR #1");					//ie.printStackTrace(); 					return;				}			}			if (lf != null) {				try {					lf.writeBytes(s);   	    	} catch (IOException ie) { 					System.err.println("APPENDLOG ERROR #2");				}			}		}	}	/**	 * Read a line of text from stdin.	 * @return a line of text from stdin	 */	public static String readLine() {		StringBuffer s = new StringBuffer();		try {			char c = 0;			while (c != '\n') {				c = (char)System.in.read();				if (c != '\n') s.append(c);			}		} catch (IOException e) {			e.printStackTrace();		}		return s.toString();	}	public static double round(double f, int precision) {		if (Double.isNaN(f)) return f;		double n = 1;		for (int i=0;i<precision;i++) n*=10;		return java.lang.Math.round(f*n)/n;	}	    public static String pad(String s, int size) {    	if (s.length() < size) return pad(s+" ", size);    	return s;    }	public void finalize() {		try {			lf.close();			lf = null;      } catch (IOException ie) { 			System.err.println("FINALIZE ERROR");			//ie.printStackTrace(); 		}	}	/**    * Load the contents of a text file into a String     * @param fname the file name    * @return the contents of the file    */	public static String loadFile(String fname) {		StringBuffer sb = new StringBuffer();		try {			File file = new File(fname);						InputStream is = new BufferedInputStream(new FileInputStream(file));     		int b = -1;      	while ((b = is.read()) != -1) {         	sb.append((char)b);			}	      is.close();		} catch (IOException e) { return null; }		return sb.toString();	}	/**    * Attempts to execute the command.	 * @param cmnd the command to execute	 * @return null if unsuccessful, or the output of the command     */	public static String loadExec(String cmnd) {     	StringBuffer sb = new StringBuffer();		try {			Runtime rt = java.lang.Runtime.getRuntime();			Process p = rt.exec(cmnd);        	InputStream is = new BufferedInputStream(p.getInputStream());			p.waitFor();         	int b = -1;         	while ((b = is.read()) != -1) {            	sb.append((char)b);         	}		} catch (InterruptedException ie) {			return null;      	} catch (IOException e) { 			return null; 		}      return sb.toString();   }	/**    * Prompt the user for a string.    * @param the text prompt    * @return what the user typed.    */	public String prompt(String s) {		reportb(s);		String r = readString();		if (r != null && r.length() > 0) return r;		else return prompt(s);	}		/**    * Return the next line typed by the user.    * @return what the user typed.    */	public static String readString() {      String aString;      System.out.flush(); // Make sure all output is flushed      try {         aString = reader.readLine();      } catch (Exception e) {         return null;      }      return aString;   }	/**    * wait for the user to type enter.    */	public static void pause() {		try {         reader.readLine();      } catch (Exception e) {}		//Keyboard.in.pause();	}	public String format(String s) {	 	return s.toLowerCase().trim();	}			public static boolean fileExists(String s) {		File f = new File(s);		return f.exists();	}}