/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker.util;import java.io.*;import java.util.*;/** * Handles the storage and retrieval of program preferences * Note. '=' is a reserved character and may not be used  * to name preferences or within their values. * * @author  Aaron Davidson <davidson@cs.ualberta.ca> * @version 1.0.0 */public class Preferences {	String fName = null;	Hashtable prefs = new Hashtable();		/**	 * Create a new set of Preferences from a given file.	 * @param file the file name storing preferences	 */	public Preferences(String file) {		fName = file;		loadPreferences(fName);	}		/**    * Load preferences fresh from disk     */	public Preferences(String prefstr, boolean notAfile) {		prefs = new Hashtable();		StringTokenizer stn = new StringTokenizer(prefstr, "\n");		while(stn.hasMoreTokens()) {			parsePrefLine(stn.nextToken());		}			}		private void parsePrefLine(String s) {		if (s.startsWith("#") || s.length() <= 2) 			return;		if (s.startsWith(">")) {			StringTokenizer st = new StringTokenizer(s, ">");			if (st.countTokens() == 1) {				String fn = st.nextToken();				File f = new File(fName);				String path = f.getParent();				if (path != null)					loadPreferences(path + "/" + fn);				else					loadPreferences(fn);			}		} else {			StringTokenizer st = new StringTokenizer(s, "=");			if (st.countTokens() == 2) {				prefs.put(st.nextToken(),st.nextToken());			}		}	}	public boolean empty() {		return (prefs.size() == 0);	}	/**	 * given a key preference name, obtain its value.	 * @param name the name of the preference.	 * @return the value of the preference	 */	public synchronized String getPreference(String name) {		return (String)prefs.get(name);	}			/**	 * given a key preference name, obtain its value as an int.	 * @param name the name of the preference.	 * @return the value of the preference	 */	public synchronized int getIntPreference(String name) {		try {			String s = this.getPreference(name);			if (s != null)				return Integer.decode(s).intValue();			else				return -1;		} catch (NullPointerException npe) {			return -1;		} catch (Exception e) {			return -1;		}	}	/**	 * given a key preference name, obtain its value as an int.	 * @param name the name of the preference.	 * @return the value of the preference	 */	public synchronized double getDoublePreference(String name) {		String str = this.getPreference(name);		if (str == null) return -1;		return (new Double(str)).doubleValue();	}		/**	 * given a key preference name, obtain its value as a boolean value.	 * @param name the name of the preference.	 * @return the value of the preference	 */	public synchronized boolean getBooleanPreference(String name) {		String str = this.getPreference(name);		if (str == null) return false;		return str.equals("true");	}			/**		 * Set a preference.	 * @param name name of the preference to set	 * @param val value of the preference to set	 */	public synchronized void setPreference(String name, String val) {		prefs.put(name,val);	}				/**		 * Set a preference.	 * @param name name of the preference to set	 * @param val value of the preference to set	 */	public synchronized void setPreference(String name, int val) {		prefs.put(name, Integer.toString(val));	}		/**		 * Set a preference.	 * @param name name of the preference to set	 * @param val value of the preference to set	 */	public synchronized void setPreference(String name, boolean val) {		prefs.put(name, (new Boolean(val)).toString());	}	/**		 * Set a preference.	 * @param name name of the preference to set	 * @param val value of the preference to set	 */	public synchronized void setPreference(String name, double val) {		prefs.put(name, (new Double(val)).toString());	}	/**    * Flush current preferences to disk.    */	public synchronized void savePreferences() {		try {			RandomAccessFile f = new RandomAccessFile(fName,"rw");			Enumeration e = prefs.keys();			while (e.hasMoreElements()) {				String k = (String)e.nextElement();				String s = k+"="+(String)prefs.get(k)+"\n";				f.writeBytes(s);			}			while (f.getFilePointer() < f.length()) f.write('\n');			f.close();		} catch (IOException e) {			e.printStackTrace();		}	}		public String toString() {		StringBuffer sb = new StringBuffer();		Enumeration e = prefs.keys();		while (e.hasMoreElements()) {			String k = (String)e.nextElement();			sb.append(k);			sb.append("=");			sb.append((String)prefs.get(k));			sb.append("\n");		}		return sb.toString();	}		/**    * Load preferences fresh from disk     */	public synchronized void loadPreferences(String fname) {		//System.out.println("load " + fname);		try {			RandomAccessFile f = new RandomAccessFile(fname,"r");			StringTokenizer st;			while (f.getFilePointer() < f.length()) {				String s = f.readLine();				parsePrefLine(s);			}			f.close();		} catch (FileNotFoundException fnf) {		//	System.err.println("FILE NOT FOUND: " + fname);		} catch (IOException e) {		//	e.printStackTrace();		}	}	   /**    * convert a string so that it fits all on one line 	 * (required for a valid preference string)    */	public static String munkString(String s) {		StringBuffer sb = new StringBuffer();		for (int i=0;i<s.length();i++) {			char c = s.charAt(i);			if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || 				(c >= '0' && c <= '9') || (c=='.') || (c == '-'))  {				sb.append(c);			} else {				sb.append('{');				sb.append(Integer.toString((int)c));				sb.append('}');			}		}		return sb.toString();	}	   /**    * Take a munked-up string and fix it.    */	public static String unmunkString(String s) {		StringBuffer sb = new StringBuffer();		for (int i=0;i<s.length();i++) {			char c = s.charAt(i);			if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || 				(c >= '0' && c <= '9') || (c=='.') || (c == '-'))  {				sb.append(c);			} else if (c == '{') {				StringBuffer cb = new StringBuffer();				while (c != '}') {					c = s.charAt(++i);					if (c != '}') cb.append(c);				}				c = (char)(Integer.decode(cb.toString()).intValue());				sb.append(c);			}		}		return sb.toString();	}	}