/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker.util;import java.io.*;/** * This class stores a resizable array of bytes. * Bytes can be read/written into other variable formats. * * @author  Aaron Davidson <davidson@cs.ualberta.ca> * @version 1.0.1 */public class ByteArray {	private byte[] v = null;	private int count = 0;	private int pos = 0;	public ByteArray() { 		 this(16);	}	/**	 * Construct a ByteArray with the given starting capacity	 * @param length the starting capacity of the ByteArray	 */ 	public ByteArray(int length) {    	v = new byte[length];  	}  	  	/**  	 * Construct a ByteArray from the bytes of a file.  	 * @param file the file to open and read the bytes from  	 */  	public ByteArray(File file) throws IOException {    	this(1024);    	InputStream is = new BufferedInputStream(new FileInputStream(file));    	int b = -1;    	while ((b = is.read()) != -1) {    		if (b == 13) b = 10;    	  	append((byte)b);    	}    	is.close();  	}  	/**  	 * Write a serializable object to the ByteArray  	 * @param file the file to open and read the bytes from  	 */  	public void appendObject(Serializable o) throws IOException { 		ByteArrayOutputStream bs = new ByteArrayOutputStream();    	ObjectOutputStream oos = new ObjectOutputStream(bs);		oos.writeObject(o); 		byte[] bts = bs.toByteArray();    	append((int)bts.length);    	append(bts);    	oos.close();		//System.out.println("Appended object " + bts.length + "  bytes");  	}  	/**  	 * Write a serializable object to the ByteArray  	 * @param file the file to open and read the bytes from  	 */  	public Object readObject() throws IOException {		Object o = null;    	int oSize = readInt();		byte[] bts = new byte[oSize];		for (int i=0;i<oSize;i++)			bts[i] = readByte();		//System.out.println("Reading object " + bts.length + "  bytes");		ByteArrayInputStream bs = new ByteArrayInputStream(bts);		try {	    	ObjectInputStream ois = new ObjectInputStream(bs);			o = ois.readObject();	    	ois.close();		} catch (ClassNotFoundException e) {			return null;		}			return o;  	}  	 	/**  	 * Construct a ByteArray from the bytes of a file.  	 * @param file the file to open and read the bytes from  	 */  	public void appendFile(String fname) {  		try {	  		RandomAccessFile f = new RandomAccessFile(fname,"r");			while (f.getFilePointer() < f.length()) {				byte[] bts = new byte[(int)f.length()];				f.readFully(bts);				append(bts);			}			f.close();		} catch (IOException e) {			e.printStackTrace();		}  	}	/**	 * Construct a ByteArray from an array of bytes	 * @param b the bytes to place in the ByteArray.	 *	 */	public ByteArray(byte[] b) {		v = b;		count = b.length;	}		/**	 * Erase and empty the contents of the ByteArray	 */	public synchronized void clear() {		int len = v.length;		v = new byte[len];		count = 0;	}		/**	 * @return the number of bytes.	 */	public synchronized int size() {		return count;	}		/**	 * Obtain the current capacity	 * @return the current capacity	 */	public synchronized int capacity() {    	return v.length;  	}  	/**	 * Append an array of bytes	 */	public synchronized void append(byte[] b) {	 	int len = b.length;    	int newcount = count + len;    	if (newcount > v.length) expandCapacity(newcount);    	System.arraycopy(b, 0, v, count, len);    	count = newcount;    }		/**	 * Append a ByteArray	 */	public synchronized void append(ByteArray b) {		this.append(b.getBytes());	}		/**	 * Append a byte	 */	public synchronized void append(byte b) {		int newcount = count + 1;    	if (newcount > v.length) expandCapacity(newcount);    	v[count++] = b;	}		/**	 * Append a String.	 * Note: will be null-terminated.	 */	public synchronized void append(String s) {		append(s.getBytes());		append((byte)0);	}		/**	 * Append a String.	 * Note: C style string.	 */	public synchronized void append(String s, int size) {		byte[] b = s.getBytes();		for (int i=0;i<size;i++) {			if (i < b.length) append(b[i]);			else append((byte)0);		}	}			public synchronized void append(String s, boolean addSize) {		if (addSize)			append(s.length());		append(s.getBytes());	}			/**	 * Append an int (4 bytes)	 */	public synchronized void append(int n) {		this.append(intToBytes(n));	}		/**	 * Append a long	 */	public synchronized void append(long n) {		this.append(longToBytes(n));	}		/**	 * Append a double	 */	public synchronized void append(double db) {		append((long)Double.doubleToLongBits(db));	}		public synchronized void write(int i, int n) {		byte[] b = intToBytes(n);		setByte(i,   b[0]);		setByte(i+1, b[1]);		setByte(i+2, b[2]);		setByte(i+3, b[3]);	}		/**	 * Obtain the actual bytes stored.	 * @return the array of bytes	 */	public synchronized byte[] getBytes() {		byte[] r = new byte[count];		System.arraycopy(v, 0, r, 0, count);		return r;	}			/**	 * Get the byte stored at a given index.	 * @param i the position in the array to read a byte	 */	public synchronized byte getByte(int i) {		if ((i < 0) || (i >= count)) {      		throw new IndexOutOfBoundsException(Integer.toString(i));    	}	    	return v[i];	}			public synchronized byte readByte() {		return getByte(pos++);	}			/**	 * Set the byte at a given index	 * @param i the index to set	 * @param b the byte to write	 */	public synchronized void setByte(int i, byte b) {		if ((i < 0) || (i >= count)) {      		throw new IndexOutOfBoundsException(Integer.toString(i));    	}	    	v[i] = b;	}		/**	 * Read a string from the ByteArray.	 * Reads until the end of the ByteArray, or until a null character is reached.	 * @param i the index to start reading from	 * @return the string read from the ByteArray	 */	public synchronized String getString(int i) {		if (i < 0 || i >= count)			return null;		ByteArray str = new ByteArray();		while (i < this.size() && this.getByte(i) != (byte)0) {			str.append(this.getByte(i));			i++;		}		return new String(str.getBytes());	}		/**	 * Read a string of a specific length from the ByteArray.	 * @param i the index to start reading from	 * @param l the length of the string	 * @return the string read from the ByteArray	 */	public synchronized String getString(int i, int l) {		if (i < 0 || i >= count) return null;		ByteArray str = new ByteArray();		while (i < i+l && i < count && this.getByte(i) != (byte)0) {			str.append(this.getByte(i));			i++;		}		return new String(str.getBytes());	}	/**	 * Read a string of a specific length from the ByteArray.	 * @return the string read from the ByteArray	 */	public synchronized String readPString() {		if (pos >= count) return null;		ByteArray str = new ByteArray();		int l = readInt();		for (int i=0;i<l&&pos<count;i++)			str.append(this.readByte());		return new String(str.getBytes());	}		/**	 * Read a null terminated string from the ByteArray.	 * @return the string read from the ByteArray	 */	public synchronized String readString() {		if (pos >= count) return null;		ByteArray str = new ByteArray();		byte b = this.readByte();		while (b != (byte)0 && pos < count) {			str.append(b);			b = this.readByte();		}		return new String(str.getBytes());	}		public synchronized ByteArray getByteArray(int i, int l) {		if (l <= 0) return new ByteArray();		return new ByteArray(getBytes(i,l));	}			public synchronized ByteArray readByteArray(int l) {		if (l <= 0) return new ByteArray();		return new ByteArray(getBytes(pos,l));	}	public synchronized byte[] getBytes(int i, int size) {		if (size < 1 || i < 0 || i >= count) return null;		size = (i+size < count ? size : count - i);		byte[] b = new byte[size];		System.arraycopy(v, i, b, 0, size);		return b;	}				/**	 * Read an int (4 bytes) from the ByteArray	 * @param i the index to read from	 * @param the int value stored at that location.	 */	public synchronized int getInt(int i) {		if (i < 0 || size() < i+4) return -1;				byte[] b = new byte[4];		b[0] = getByte(i);		b[1] = getByte(i+1);		b[2] = getByte(i+2);		b[3] = getByte(i+3);		return bytesToInt(b);	}	/**	 * Read an int (4 bytes) from the ByteArray	 * @param i the index to read from	 * @param the int value stored at that location.	 */	public synchronized int readInt() {		int i = getInt(pos);		pos+=4;		return i;	}				/**	 * Read an long (8 bytes) from the ByteArray	 * @param i the index to read from	 * @param the int value stored at that location.	 */	public synchronized long getLong(int i) {		if (i < 0 || size() < i+8) return -1;		byte[] b = new byte[8];		b[0] = getByte(i);		b[1] = getByte(i+1);		b[2] = getByte(i+2);		b[3] = getByte(i+3);		b[4] = getByte(i+4);		b[5] = getByte(i+5);		b[6] = getByte(i+6);		b[7] = getByte(i+7);		return bytesToLong(b);	}	/**	 * Read a long (8 bytes) from the ByteArray	 * @param i the index to read from	 * @param the int value stored at that location.	 */	public synchronized long readLong() {		long l = getLong(pos);		pos+=8;		return l;	}	/**	 * Read a double (8 bytes) from the ByteArray	 * @param i the index to read from	 * @param the int value stored at that location.	 */	public synchronized double readDouble() {		long l = readLong();		return Double.longBitsToDouble(l);	}	/**	 * Convert to a string representation	 * @return a string made from the bytes in the array	 */ 	public synchronized String toString() {    	StringBuffer sb = new StringBuffer(count);    	for(int i=0;i<count;i++) {      		sb.append((byte)v[i]+"_");    	}    	return sb.toString();  	}	/**	 * Ensure that the ByteArray has a minimal capacity.	 * If the capacity does not exist, it will expand the capacity	 * @param minimumCapacity the minimal capacity needed	 */  	public synchronized void ensureCapacity(int minimumCapacity) {    	if (minimumCapacity > v.length) {      		expandCapacity(minimumCapacity);    	}  	}  	private void expandCapacity(int minimumCapacity) {    	int newCapacity = (v.length + 1) * 2;    	if (minimumCapacity > newCapacity) {      		newCapacity = minimumCapacity;    	}    	byte newValue[] = new byte[newCapacity];    	System.arraycopy(v, 0, newValue, 0, count);    	v = newValue;  	}	/** 	 * Set the size of the ByteArray	 * @param newLength the new length	 */  	public synchronized void setSize(int newLength) {    	if (newLength < 0) {      		throw new IndexOutOfBoundsException(Integer.toString(newLength));    	}    	if (newLength > v.length) {      		expandCapacity(newLength);    	}    	if (count < newLength) {      		for (; count < newLength; count++) {        		v[count] = 0;      		}    	} else {      		count = newLength;    	}  	}  	  	/**  	 * Write the contents of the ByteArray to a file.  	 * @param f the file to write to.  	 */  	public void writeToFile(File f) throws IOException {    	OutputStream os = new BufferedOutputStream(new FileOutputStream(f));  		os.write(getBytes()); 		os.close(); 		  	}  	  	  	public int getPos() {  		return pos;  	}	public void reset() {		pos = 0;	}		/**	 * Converts a long to a 4-byte array. 	 *	 */	public static byte[] intToBytes (int n) {		byte r[] = new byte[4];		r[3] = (byte) (n & 0x000000FF);		r[2] = (byte) ((n >> 8) & 0x000000FF);		r[1] = (byte) ((n >> 16) & 0x000000FF);		r[0] = (byte) ((n >> 24) & 0x000000FF);		return (r);	}			public static int bytesToInt (byte[] b) {		int r;		r =  (int)((b[3] < 0 ? 256+b[3] : b[3]));		r += (int)((b[2] < 0 ? 256+b[2] : b[2]) << 8);		r += (int)((b[1] < 0 ? 256+b[1] : b[1]) << 16);		r += (int)((b[0] < 0 ? 256+b[0] : b[0]) << 24); 		return (r);	}		/**	 * Converts a long to a 8-byte array. 	 *	 */	public static byte[] longToBytes (long n) {		byte r[] = new byte[8];		r[7] = (byte) (n & 0x000000FF);		r[6] = (byte) ((n >> 8) & 0x000000FF);		r[5] = (byte) ((n >> 16) & 0x000000FF);		r[4] = (byte) ((n >> 24) & 0x000000FF);				r[3] = (byte) ((n >> 32) & 0x000000FF);		r[2] = (byte) ((n >> 40) & 0x000000FF);		r[1] = (byte) ((n >> 48) & 0x000000FF);		r[0] = (byte) ((n >> 56) & 0x000000FF);				return (r);	}			public static long bytesToLong(byte[] b) {		int r;		r =  (int)((b[7] < 0 ? 256+b[7] : b[7]));		r += (int)((b[6] < 0 ? 256+b[6] : b[6]) << 8);		r += (int)((b[5] < 0 ? 256+b[5] : b[5]) << 16);		r += (int)((b[4] < 0 ? 256+b[4] : b[4]) << 24); 		r += (int)((b[3] < 0 ? 256+b[3] : b[3]) << 32); 		r += (int)((b[2] < 0 ? 256+b[2] : b[2]) << 40); 		r += (int)((b[1] < 0 ? 256+b[1] : b[1]) << 48); 		r += (int)((b[0] < 0 ? 256+b[0] : b[0]) << 56); 				return (r);	}	}