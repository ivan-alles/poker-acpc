/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker;import poker.util.*;import poker.ai.*;import java.io.*;import java.util.Vector;/** * Stores all of the information for a player during a  poker game.  * Also contains references to a player's past history of games. * * This class is a little messy from evolution, and has some  * ugly hooks for the AI system. * * @author  Aaron Davidson * @version 2.0.0 */public class PlayerInfo {	private String		pName;  		// index name and id	private int 		bankRoll;		// player's money	private int     	amount_in = 0; 	// money spent this game	private String  	revHand;		// revealed hand	private GameInfo  gInfo;			// game state information	private Preferences pPrefs = null;			private int 	last_amount_called; // last amount called	private double 	last_betstocall;  	private Context gContext;  	private int last_action;  	private int lcode;	private int 	curIndex = 0; 	// index into current action	private String  actions; 		// game action list		// flagged if player has voluntarily committed 	// money to the pot during the current betting round	private boolean	committed = false;	private double delta = 0;	private double winnings = 0;	private int num_games = 0;	 	/**	 * Constructor.	 * @param playerName the name of the player	 * @param gi         the game that the player is in	 */	public PlayerInfo(String playerName, GameInfo gi) {		pName = playerName;		gInfo = gi;	}	/**	 * Constructor.	 * @param playerName the name of the player	 * @param gi         the game that the player is in	 */	public PlayerInfo(String playerName, String fname, GameInfo gi) {		pName = playerName;		gInfo = gi;		if (fname != null)			load(fname);	}		private void load(String fname) {		if (pPrefs == null)			pPrefs = new Preferences(fname);		if (pPrefs.empty() || pPrefs.getPreference("BANKROLL") == null) {			delta = bankRoll = 0;			return;		}		num_games = pPrefs.getIntPreference("NUM_GAMES");		delta = bankRoll = pPrefs.getIntPreference("BANKROLL");		winnings = pPrefs.getDoublePreference("WINNINGS");	}	public void save() {		double gain = getNetGain();		winnings += gain;		// log winnings to history file if there is one specified		Reporter.log(winnings+"\n", gInfo.LOG_DIR+pName.toLowerCase()+".win");		pPrefs.setPreference("NUM_GAMES", num_games);		pPrefs.setPreference("BANKROLL", bankRoll);		pPrefs.setPreference("WINNINGS", (double)winnings);		pPrefs.setPreference("NAME", pName);		pPrefs.savePreferences();	}	public double getNetGain() {		return (double)((bankRoll - delta)/(double)gInfo.getLowBet());	}		public void setBankRoll(int br) { bankRoll = br; }	public int getBankRoll() { return bankRoll; }	/**	 * Start a new game with this player	 */	public void startNewGame() {		actions = new String();		revHand = new String("-");		amount_in = 0;				delta = (double)bankRoll;		last_amount_called = 0;		last_betstocall = 0;		committed = false;		last_action = -1;		lcode = -1;		num_games++;	}		/**	 * obtain the player's name 	 * @return the name of this player	 */	public String getName() { return new String(pName); }	/**	 * Obtain a string representation of the player's actions.	 * Ex: crc/rc/cf  c = check/call, r = bet/raise, f = fold, / = end of betting	 * @return String of actions	 */	public String getActions() { return new String(actions); }	/** 	 * Have the player pay what it owes to the pot.	 * Note: Called only by Holdem.	 * @param owed The amount which the player should have in the pot (not necessarily what is owed)	 * @return The amount which the player has paid to the pot to owe nothing	 */	protected int pay(int owed) {		int amount = owed - amount_in;		amount_in = owed;		bankRoll -= amount;				return amount;	}	/**	 * Determine if a player is All-In	 * @return true if all in, false otherwise 	 */	public boolean allIn() {		return (bankRoll == 0);	}	/**	 * The Player has folded	 */	protected void fold() {		double bets = gInfo.getBetsToCall(gInfo.getPlayerPosition(pName));				logContext(Holdem.FOLD, bets);				last_betstocall = bets;		actions += 'f';		last_action = Holdem.FOLD;	}		/**	 * The Player pays the small blind	 */	protected void smallBlind() {		actions += 's';		last_amount_called = amount_in;	}		/**	 * The player pays the big blind	 */	protected void bigBlind() {		actions += 'B';		last_amount_called = amount_in;	}		/**	 * The player calls	 */	protected int call(int owed) {		int amount = owed - amount_in;		if (amount == 0) { check(); return 0; }		int bets = amount/gInfo.getBetSize();		//bets = (bets >= 2 ? 2 : bets);		logContext(Holdem.CALL, bets);		last_action = Holdem.CALL;		amount_in = owed;		bankRoll -= amount;		actions += 'c';		last_betstocall = bets;		last_amount_called = amount;		committed = true;		return amount;	}	/**	 * The player bets	 */	protected int bet(int owed) {		logContext(Holdem.BET, 0);		int amount = owed - amount_in;		amount_in = owed;		bankRoll -= amount;		last_action = Holdem.BET;		committed = true;		actions += 'b';		last_amount_called = amount;		last_betstocall = 0;		return amount;	}	/**	 * The player checks	 */	protected void check() {		logContext(Holdem.CHECK, 0);		last_action = Holdem.CHECK;		actions += 'k';		last_amount_called = 0;		last_betstocall = 0;	}		/**	 * The player raises	 */	protected int raise(int owed) {		int amount = owed - amount_in;				double betstocall = (amount/(double)gInfo.getBetSize()) - 1;		logContext(Holdem.RAISE, betstocall);				bankRoll -= amount;		amount_in = owed;		last_action = Holdem.RAISE;		last_betstocall = betstocall;		committed = true;		actions += 'r';		last_amount_called = amount;		return amount;	}		/**	 * The betting round is over	 */	protected void advanceStage() {		actions += '/';		committed = false;		last_amount_called = 0;		last_betstocall = 0;	}		/**	 * Convert a character representing an action to an Action number.	 * @param c the character to convert	 * @return the action number	 */	public int charToAction(char c) {		switch (c) {			case 'f': return Holdem.FOLD;			case 'c': return Holdem.CALL; 			case 'r': return Holdem.RAISE;			case 'b': return Holdem.SMALL_BLIND;			case 'B': return Holdem.BIG_BLIND;			default: break;		}		return -1;	}		/**	 * Obtain a specific action from the player's actions.	 * @param stage The betting round at which the action too place	 * @param step  The nth action taken during that betting round	 * @return	the specified action (-1 if position does not exist)	 */	public int getAction(int stage, int step) {		int i,j;		for (i=0, j=0; j < stage; i++) {			if (i >= actions.length()) return -1;			if (actions.charAt(i) == '/') j++;		}		j = i+step;		if (j >= actions.length()) return -1;			for (i=i+1; i<=j; i++) {				if (actions.charAt(i) == '/') return -1;			}		return charToAction(actions.charAt(j));	}		/**	 * Obtain the last action made by the player	 * @return the last action or -1 if no action has been made yet	 */	public int getLastAction() {		if (actions.length() == 0) return -1;		if (actions.charAt(actions.length()-1) == '/' && actions.length() > 1)		    	return charToAction(actions.charAt(actions.length()-2));  		return charToAction(actions.charAt(actions.length()-1));	}	/**	 * Give the player some money	 * @param amount the amount of money to give	 */	public void win(int amount) {		bankRoll += amount;	}	/**	 * Reveal the hole cards in a showdown	 * @param c1 the first card	 * @param c2 the second card	 */	public void revealHand(Card c1, Card c2) {		revHand = c1.toString() + "-" + c2.toString();	}		/**	 * Obtain the hand revealed by this player	 * @return the player's hand, or null if unrevealed	 */	public Hand getRevealedHand() {		if (revHand != null && !revHand.equals("-")) 			return new Hand(revHand);		else return null;	}	/**	 * Determine the amount a player must pay to stay in the game	 * @param amount_needed the total amount the player should have in the pot	 * @return the amount needed to stay in.	 */	public int getAmountToCall(int amount_needed) {		return amount_needed - amount_in;	}	/**	 * Test if a player has volunatrily committed yet in this round	 * @return true if player is committed, false if not.	 */	public boolean isCommitted() {		return committed;	}	/**	 * Obtain the player's pot odds	 * @return the pot odds.	 */	public double potOdds() {		int am = getAmountToCall(gInfo.getBetAmount());		return (double)am / (double)(gInfo.getPot() + am);	}	/**	 * Obtain the player's predicted future pot odds	 * @return the predicted pot odds.	 */	public double potOdds2() {		return (double)((2*gInfo.getBetSize()) / (gInfo.getPot() + 6*gInfo.getBetSize()));	}	/**	 * Get the amount called by this player during his last action	 */	public int getLastAmountCalled() {		return last_amount_called;	}	/**	 * Obtain the amount of bets the player had to call during	 * their last action.	 */	public double getLastBetsToCall() {		return last_betstocall;	}		/**	 * Obtain the amount the player has put in the pot.	 */	public int getAmountInPot() {		return amount_in;	}	/**	 * Log a context file (used to train neural nets for opponent move precition, etc...)	 */		private void logContext(int action, double bets) {		Context c = new Context(this, action, bets);		/*			double potodds = (double)bets / (double)((gInfo.getPot()/(double)gInfo.getBetSize()) + bets);			c.setActionContext(action, bets, committed, gInfo.getStage(), potodds, gInfo.getNumRaises());			c.setPlayerContext(gInfo.getNumPlayers(), gInfo.getNumActivePlayers(),								 gInfo.getUnacted(), gInfo.getPlayerPosition(pName), gInfo.getButton(), false);			c.setHistoryContext(last_action, (int)getLastBetsToCall(), betRatio());			c.setGameContext(gInfo.getPot(), gInfo.getBetSize(), gInfo.getID());			c.setBoardContext(gInfo.getBoard());		*/		gContext = c;		lcode = getLastActionCode();	}	/**	 * The bet ratio is the number of times a player bet divided by the	 * number of chances they had to bet (a measure of agressiveness)	 */	public double betRatio() {		int b=0,t=0;		String s = getActions();		for (int i=0;i<s.length();i++) {			if (s.charAt(i) != '/') {				t++;				if (s.charAt(i) == 'r')					b++;			}		}		return (double)b/(double)t;	}	/**    * The ratio of the money in the pot that belongs to the player     */	public double potRatio() {		return (double)amount_in/(double)gInfo.getPot();	}	/**    * A single integer code for the last action made     */	public int getLastActionCode() {		return Context.getLastActionCode(last_action,(int)getLastBetsToCall());	}	/**    * A single integer code for the last action made     */	public int lastAction() {		return last_action;	}	/**	 * Get the context of the last action made by this player.	 */	public Context getActionContext() {		return gContext;	}	/**	 * Get the context of the last action made by this player.	 */	public GameInfo getGameInfo() {		return gInfo;	}}