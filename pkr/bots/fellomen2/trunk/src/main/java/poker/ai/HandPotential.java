/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker.ai;import poker.*;import poker.ai.model.*;import poker.util.*;import java.util.Hashtable;/** * <B>Hand Potential.</B><BR> * Hand Potential is the calculation of the probability * that a hand that is currently behind will be ahead as more * board cards are dealt. Negative Potential (NPOT) is the * probability that given that we are currently ahead, future * cards will put is behind. * * Contains the Hand Potential Calculations as described in:<BR> * <CITE> *	<I>Dealing with Imperfect Information in Poker.</I><BR>  *	Denis Papp, M.Sc. thesis, 1998.  * </CITE> * As well as Darse Billings' crude potential function. *  * * @author  Aaron Davidson * @version 1.1.0 */public class HandPotential {	private static HandEvaluator 	he;	private Deck   d = new Deck();	private final static int AHEAD = 0;	private final static int TIED = 1;	private final static int BEHIND = 2;		private final static int NUM_SUITS = 4;	private final static int NUM_RANKS = 13;	private final static int TWO = 0;	private final static int ACE = 12;	private double	ppot=-1,npot=-1,nr=0;			public HandPotential() {		he = new HandEvaluator();	}			/**	 * obtain the PPot calculated during the last call to ppot.	 * @return the last calculated ppot.	 */	public double getLastPPot() { return ppot; }	/**	 * obtain the PPot calculated during the last call to npot.	 * @return the last calculated npot.	 */	public double getLastNPot() { return npot; }		/** 	 * Calculate the PPot and NPot of a hand. (Papp 1998, 5.3)	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param bd the board cards	 * @param w the weight table to use	 * @param full if true, a full 2-card look ahead will be done (slow)	 * @return the ppot (also sets npot variable accessible with getLastNPot())	 */	public double ppot(Card c1, Card c2, Hand bd, WeightTable w, boolean full) {		double[][] 	HP = new double[3][3]; // init to 0		double[] 	HPTotal = new double[3]; // init to 0		double		wInc=0;		int			ourrank5,ourrank7,opprank;		int 			i,j,k,l,index;		Hand			board = new Hand(bd);		Hand 			myHand = new Hand(board);		Hand 			opHand = new Hand(board);		boolean		TwoCardLookAhead = (board.size()==3 && full);		Card			o1,o2;		int			o1i,o2i;		int[]		e = new int[4];      for (i=0;i<3;i++) {         HPTotal[i] = 0;         for (j=0;j<3;j++)            HP[i][j] = 0;      }		if (myCache6 == null) 			myCache6 = new int[52];		if (myCache == null && TwoCardLookAhead == true)			myCache = new int[52][51];		if (oppCache == null && TwoCardLookAhead == true)			oppCache = new int[270725];		if (oppCache6 == null)			oppCache6 = new int[22100];   	 for (i=0;i<52;i++) {         myCache6[i] = 0;         if (TwoCardLookAhead==true)            for (j=0;j<51;j++)               myCache[i][j] = 0;      }      if (TwoCardLookAhead==true) {         for (i=0;i<22100;i++) {            oppCache6[i] = 0;            oppCache[i] = 0;         }         for (i=22100;i<270725;i++)            oppCache[i] = 0;      } else {         for (i=0;i<22100;i++)            oppCache6[i] = 0;      }		myHand.addCard(c1);		myHand.addCard(c2);		ourrank5 = he.rankHand(myHand);		// remove all known cards		d.reset();		d.extractCard(c1);				d.extractCard(c2);				d.extractHand(board);		// tally all possiblities		for (i=d.getTopCardIndex();i<52;i++) {			o1 = d.getCard(i);			o1i = o1.getIndex();						opHand.addCard(o1);			e[0] = o1i;				for (j=i+1;j<52;j++) {				o2 = d.getCard(j);				o2i = o2.getIndex();							opHand.addCard(o2);				e[1] = o2i;					opprank = he.rankHand(opHand);				if (ourrank5>opprank) index = AHEAD;				else if (ourrank5==opprank) index = TIED;				else index = BEHIND;				wInc = w.getCell(o1i,o2i);				HPTotal[index] += wInc;				for (k=d.getTopCardIndex();k<52;k++) { 					if (k == i || k == j) continue;						if (TwoCardLookAhead==true) {						for (l=k+1;l<52;l++) {		 					if (l == i || l == j) continue;							ourrank7 = getCachedRank(d.getCard(k),d.getCard(l),myHand);							e[0] = o1i; e[1] = o2i;							e[2] = d.getCard(k).getIndex();								e[3] = d.getCard(l).getIndex();								opprank = getCachedRank(e,board);							if (ourrank7 > opprank) HP[index][AHEAD] += wInc;							else if (ourrank7 == opprank) HP[index][TIED] += wInc;							else HP[index][BEHIND] += wInc;						}					} else { // 1 card look ahead						ourrank7 = getCachedRank(d.getCard(k), myHand);						opprank = getCachedRank(o1,o2,d.getCard(k), board);						if (ourrank7 > opprank) HP[index][AHEAD] += wInc;						else if (ourrank7 == opprank) HP[index][TIED] += wInc;						else HP[index][BEHIND] += wInc;					}				} /* end of look ahead */				opHand.removeCard();			}			opHand.removeCard();		} /* end of possible opponent hands */			int mult = (TwoCardLookAhead ? 990 : 45);		double den1 = (mult*(HPTotal[BEHIND] + (HPTotal[TIED]/2.0)));		double den2 = (mult*(HPTotal[AHEAD] + (HPTotal[TIED]/2.0)));		if (den1 > 0) 			ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED]/2) + (HP[TIED][AHEAD]/2)) / (double)den1;		else ppot = 0;			if (den2 > 0) 			npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED]/2) + (HP[TIED][BEHIND]/2)) / (double)den2;		else npot = 0;		return ppot;	}	private	int[][] myCache;	private	int[]   myCache6;	private	int[]   oppCache;	private	int[]   oppCache6;	private int getCachedRank(Card c, Hand h) {		int i = c.getIndex();		if (myCache6[i] > 0) return myCache6[i];		h.addCard(c);		myCache6[i] = he.rankHand(h);		h.removeCard();		return myCache6[i];	}	private int getCachedRank(Card c1, Card c2, Hand h) {		int i = c1.getIndex();		int j = c2.getIndex();		if (i < j) { int t = i; i = j; j = t; }		if (myCache[i][j] > 0) return myCache[i][j];		h.addCard(c1);		h.addCard(c2);		myCache[i][j] = he.rankHand7(h);		h.removeCard();		h.removeCard();		return myCache[i][j];	}	private int getCachedRank(Card c1, Card c2, Card c3, Hand h) {		int i = c1.getIndex();		int j = c2.getIndex();		int k = c3.getIndex();		if (i < k) { int t = i; i = k; k = t; }		if (j < k) { int t = j; j = k; k = t; }		if (i < j) { int t = i; i = j; j = t; }		int ind = k + choose(j,2) + choose(i,3);		int v = oppCache6[ind];		if (v > 0) return v;		h.addCard(i);		h.addCard(j);		h.addCard(k);		oppCache6[ind] = v = he.rankHand(h);		h.removeCard();		h.removeCard();		h.removeCard();		return v; 	}	private int getCachedRank(int[] c, Hand h) {		// bubble sort :-p		boolean flag = true;		while (flag) {			flag = false;			if (c[0]<c[1]) { swap(c,0,1); flag = true; }			if (c[1]<c[2]) { swap(c,1,2); flag = true; }			if (c[2]<c[3]) { swap(c,2,3); flag = true; }		}		int i = c[3] + choose(c[2],2) + choose(c[1],3) + choose(c[0],4);		int v = oppCache[i];		if (v > 0) return v;		h.addCard(c[0]);		h.addCard(c[1]);		h.addCard(c[2]);		h.addCard(c[3]);		oppCache[i] = v = he.rankHand7(h);		h.removeCard();		h.removeCard();		h.removeCard();		h.removeCard();		return v; 	}	private int choose(int n, int r) {		if (r==1) return n;		else return ((n-(r-1))*choose(n,r-1))/r;	}	private void swap(int[] c, int i,int j) {		int t = c[i]; 		c[i] = c[j];		c[j] = t; 	}	/**	 * A crude but fast approximation of PPOT.	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param board the board cards	 */	public static double CrudePotential1(Card c1, Card c2, Hand board) {		Hand 	h = new Hand();		double 	outs=0;		int i;		int top_r = TWO;		int rk,c,s;		int board_pair=-1;		int board_cards = board.size();		int[] num_suit = new int[NUM_SUITS];		int[] present = new int[NUM_RANKS];				h.addCard(c1);		h.addCard(c2);		for (i=0;i<board.size();i++) 			h.addCard(board.getCard(i+1));		for (i=2;i<h.size();i++) {			rk = h.getCard(i+1).getRank();			if (rk>top_r) top_r = rk;			present[rk]++;			if (present[rk]>1)				board_pair = rk;			num_suit[h.getCard(i+1).getSuit()]++;		}		// - don't care about overpair		if (h.getCard(1).getRank() != h.getCard(2).getRank()) {		   for (i=0;i<2;i++) {			int ni = ((i == 0) ? 1 : 0);			rk = h.getCard(i+1).getRank();			if (rk>top_r) outs += 0.9*(NUM_SUITS-1);			else if (top_r>h.getCard(ni+1).getRank() && top_r>rk && present[h.getCard(ni+1).getRank()]>0 && present[rk]==0)				outs += 0.95*(NUM_SUITS-1);			else if (rk<top_r && present[rk]==0) outs += 0.6*(NUM_SUITS-1);			else if (present[rk]==1 && board_pair<rk) outs += 0.95*(NUM_SUITS-1-present[rk]);			else if (present[rk]==2 && board_pair == rk) outs += 0.95 * (NUM_SUITS-1) * (board_cards - 2);		   }		} else {			if (present[h.getCard(1).getRank()] != 0) {				if (board_pair==0) {					outs += 0.9*(NUM_SUITS-1)*(board_cards-1);				}			} else {			  outs += 0.99*(NUM_SUITS-2);			  if (top_r<h.getCard(1).getRank() && board_pair==0)			      outs += 0.25*(NUM_SUITS-1)*board_cards;		    }		}		int[] num_suit_hole = new int[] {0,0,0,0};		int[] rank_suit_hole = new int[NUM_SUITS];		for (i=0;i<2;i++) {			num_suit_hole[h.getCard(i+1).getSuit()]++;			rank_suit_hole[h.getCard(i+1).getSuit()] = h.getCard(i+1).getRank();		}		for (s=0;s<NUM_SUITS;s++) {			if (num_suit[s]+num_suit_hole[s]==4) {				if (num_suit_hole[s]==1)					outs += (0.5+0.5*rank_suit_hole[s]/NUM_RANKS)*(NUM_RANKS-4);				else if (num_suit_hole[s]==2)					outs += 1.0*(NUM_RANKS-4);			}		}		// + id 4str, count hole		int gap0_straight=0;		int gap0_hole=0;		int gap1_straight=0;		int gap1_hole=0;		int r1 = h.getCard(1).getRank(), r2=h.getCard(2).getRank();				if (present[ACE]!=0) gap0_straight++;		else if (r1==ACE || r2==ACE) {			gap0_straight++;			gap0_hole++;		} else gap1_straight=1;		for (rk=0;rk<NUM_RANKS;rk++) {			if (present[rk]!=0) { 				gap0_straight++; 				gap1_straight++;			} else if (r1==rk || r2==rk) {				gap0_straight++; gap1_straight++;				gap0_hole++; gap1_hole++;			} else {				if (gap1_straight>=5) {					if (gap1_hole==0) ;					else if (gap1_hole==1) outs += 0.7*NUM_SUITS;					else outs += 1.0*NUM_SUITS;				}				// move gap0 to gap1				if (rk==ACE) { 					gap1_straight=gap0_straight;					gap1_hole=gap0_hole;				} else {					gap1_straight = gap0_straight+1;					gap1_hole = gap0_hole;				}				// reset gap0				gap0_straight=0;				gap0_hole=0;			}		}		// TERMINATE		if (gap1_straight>=5) {			if (gap1_hole==0);			else if (gap1_hole==1) outs += 0.7*NUM_SUITS;			else outs+=1.*NUM_SUITS;		}		return (double)outs/(double)(50-h.size());	}	/**	 * Calculate the raw (unweighted) PPot and NPot of a hand. (Papp 1998, 5.3)	 * @param c1 the first hole card	 * @param c2 the second hole card	 * @param bd the board cards	 * @param full if true, a full 2-card look ahead will be done (slow)	 * @return the ppot (also sets npot variable accessible with getLastNPot())	 */	public double ppot_raw(Card c1, Card c2, Hand bd, boolean full) {		double[][] 	HP = new double[3][3]; 		double[] 	HPTotal = new double[3]; 		int			ourrank7,opprank;		int 			i,j,k,l,index;		Hand			board = new Hand(bd);		boolean		TwoCardLookAhead = (board.size()==3 && full);		Card			o1,o2;		int 			ourrank5 =  he.rankHand(c1,c2,bd);		// remove all known cards		d.reset();		d.extractCard(c1);				d.extractCard(c2);				d.extractHand(board);		// pick first opponent card		for (i=d.getTopCardIndex();i<52;i++) {				o1 = d.getCard(i);					// pick second opponent card			for (j=i+1;j<52;j++) {				o2 = d.getCard(j);					opprank = he.rankHand(o1,o2,bd);				if (ourrank5 > opprank) index = AHEAD;				else if (ourrank5 == opprank) index = TIED;				else index = BEHIND;				HPTotal[index]++;				// tally all possiblities				for (k=d.getTopCardIndex();k<52;k++) {					if (i == k || j == k) continue;					board.addCard(d.getCard(k));					if (TwoCardLookAhead) {						for (l=k+1;l<52;l++) {							if (i == l || j == l) continue;							board.addCard(d.getCard(l));							ourrank7 = he.rankHand(c1,c2,board);							opprank = he.rankHand(o1,o2,board);							if (ourrank7 > opprank) HP[index][AHEAD]++;							else if (ourrank7 == opprank) HP[index][TIED]++;								else HP[index][BEHIND]++;							board.removeCard();						}					} else {						ourrank7 = he.rankHand(c1,c2,board);						opprank = he.rankHand(o1,o2,board);						if (ourrank7 > opprank) HP[index][AHEAD]++;						else if (ourrank7 == opprank) HP[index][TIED]++;							else HP[index][BEHIND]++;					}					board.removeCard();				}			}		} /* end of possible opponent hands */			int mult = (TwoCardLookAhead ? 990 : 45);		double den1 = (mult*(HPTotal[BEHIND] + (HPTotal[TIED]/2.0)));		double den2 = (mult*(HPTotal[AHEAD] + (HPTotal[TIED]/2.0)));		if (den1 > 0) 			ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED]/2) + (HP[TIED][AHEAD]/2)) / (double)den1;		else ppot = 0;			if (den2 > 0) 			npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED]/2) + (HP[TIED][BEHIND]/2)) / (double)den2;		else npot = 0;	/*	System.out.println("AHEAD ==> AHEAD = " + HP[AHEAD][AHEAD]);		System.out.println("AHEAD ==> TIED = " + HP[AHEAD][TIED]);		System.out.println("AHEAD ==> BEHIND = " + HP[AHEAD][BEHIND]);		System.out.println("TOTAL AHEAD = " + HPTotal[AHEAD] + "\n");		System.out.println("TIED ==> AHEAD = " + HP[TIED][AHEAD]);		System.out.println("TIED ==> TIED = " + HP[TIED][TIED]);		System.out.println("TIED ==> BEHIND = " + HP[TIED][BEHIND]);		System.out.println("TOTAL TIED = " + HPTotal[TIED] + "\n");		System.out.println("BEHIND ==> AHEAD = " + HP[BEHIND][AHEAD]);		System.out.println("BEHIND ==> TIED = " + HP[BEHIND][TIED]);		System.out.println("BEHIND ==> BEHIND = " + HP[BEHIND][BEHIND]);				System.out.println("TOTAL BEHIND = " + HPTotal[BEHIND] + "\n"); */		return ppot;	}public double ppot_raw(String c1String, String c2String, String handString, boolean full) {		Card c1 = new Card(c1String);		Card c2 = new Card(c2String);		Hand bd = new Hand(handString);				double[][] 	HP = new double[3][3]; 		double[] 	HPTotal = new double[3]; 		int			ourrank7,opprank;		int 			i,j,k,l,index;		Hand			board = new Hand(bd);		boolean		TwoCardLookAhead = (board.size()==3 && full);		Card			o1,o2;		int 			ourrank5 =  he.rankHand(c1,c2,bd);		// remove all known cards		d.reset();		d.extractCard(c1);				d.extractCard(c2);				d.extractHand(board);		// pick first opponent card		for (i=d.getTopCardIndex();i<52;i++) {				o1 = d.getCard(i);					// pick second opponent card			for (j=i+1;j<52;j++) {				o2 = d.getCard(j);					opprank = he.rankHand(o1,o2,bd);				if (ourrank5 > opprank) index = AHEAD;				else if (ourrank5 == opprank) index = TIED;				else index = BEHIND;				HPTotal[index]++;				// tally all possiblities				for (k=d.getTopCardIndex();k<52;k++) {					if (i == k || j == k) continue;					board.addCard(d.getCard(k));					if (TwoCardLookAhead) {						for (l=k+1;l<52;l++) {							if (i == l || j == l) continue;							board.addCard(d.getCard(l));							ourrank7 = he.rankHand(c1,c2,board);							opprank = he.rankHand(o1,o2,board);							if (ourrank7 > opprank) HP[index][AHEAD]++;							else if (ourrank7 == opprank) HP[index][TIED]++;								else HP[index][BEHIND]++;							board.removeCard();						}					} else {						ourrank7 = he.rankHand(c1,c2,board);						opprank = he.rankHand(o1,o2,board);						if (ourrank7 > opprank) HP[index][AHEAD]++;						else if (ourrank7 == opprank) HP[index][TIED]++;							else HP[index][BEHIND]++;					}					board.removeCard();				}			}		} /* end of possible opponent hands */			int mult = (TwoCardLookAhead ? 990 : 45);		double den1 = (mult*(HPTotal[BEHIND] + (HPTotal[TIED]/2.0)));		double den2 = (mult*(HPTotal[AHEAD] + (HPTotal[TIED]/2.0)));		if (den1 > 0) 			ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED]/2) + (HP[TIED][AHEAD]/2)) / (double)den1;		else ppot = 0;			if (den2 > 0) 			npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED]/2) + (HP[TIED][BEHIND]/2)) / (double)den2;		else npot = 0;	/*	System.out.println("AHEAD ==> AHEAD = " + HP[AHEAD][AHEAD]);		System.out.println("AHEAD ==> TIED = " + HP[AHEAD][TIED]);		System.out.println("AHEAD ==> BEHIND = " + HP[AHEAD][BEHIND]);		System.out.println("TOTAL AHEAD = " + HPTotal[AHEAD] + "\n");		System.out.println("TIED ==> AHEAD = " + HP[TIED][AHEAD]);		System.out.println("TIED ==> TIED = " + HP[TIED][TIED]);		System.out.println("TIED ==> BEHIND = " + HP[TIED][BEHIND]);		System.out.println("TOTAL TIED = " + HPTotal[TIED] + "\n");		System.out.println("BEHIND ==> AHEAD = " + HP[BEHIND][AHEAD]);		System.out.println("BEHIND ==> TIED = " + HP[BEHIND][TIED]);		System.out.println("BEHIND ==> BEHIND = " + HP[BEHIND][BEHIND]);				System.out.println("TOTAL BEHIND = " + HPTotal[BEHIND] + "\n"); */		return ppot;	}}/*			if (TwoCardLookAhead==true) {				for (l=k+1;l<52;l++) {					board.addCard(d.getCard(l));					// roll out opponent cards...					for (i=d.getTopCardIndex();i<52;i++) {						if (i == k || i == l) continue;						// pick first opponent card						o1 = d.getCard(i);						for (j=i+1;j<52;j++) {							// pick second opponent card							o2 = d.getCard(j);							if (j == l || j == k) continue;							// calc before new cards							opprank = oranks[o1.getIndex()][o2.getIndex()];							if (ourrank5 > opprank) index = AHEAD;							else if (ourrank5 == opprank) index = TIED;							else index = BEHIND;							HPTotal[index]++;								// calc after new cards							ourrank7 = ranks[c1.getIndex()][c2.getIndex()];							opprank = ranks[o1.getIndex()][o2.getIndex()];							if (ourrank7 > opprank) HP[index][AHEAD]++;							else if (ourrank7 == opprank) HP[index][TIED]++;								else HP[index][BEHIND]++;						}					}					board.removeCard();				} 			} else { // 1 card look ahead		*/