/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker.ai;import poker.*;import poker.util.*;import java.util.StringTokenizer;import java.io.*;/** * This messy looking class is just a simple container for a zillion * different nibblets of context information associated with player  * actions. Used for opponent modelling. * * @author   Aaron Davidson * @version  1.0.1 */public class Context {	private int 		action,committed,stage;	private int 		button, np, nap, nup, position;	private double  	bets;	private int  		lab, la, gID;	private double 	potodds, betRatio,  ppot, hs;	private Hand 		hnd, board;	private int 		numRaises, pot,betsize;	private boolean 	inhand, sawCards;		public Context() {}	public Context(PlayerInfo pi, int act, double betsCalled) {		GameInfo gi = pi.getGameInfo();		action = act;		bets = betsCalled;		committed = pi.isCommitted() ? 1 : 0;		stage = gi.getStage();		np = gi.getNumPlayers();		nap = gi.getNumActivePlayers();		nup = gi.getUnacted();		position = gi.getPlayerPosition(pi.getName());		potodds = (double)bets / 				(double)((gi.getPot()/(double)gi.getBetSize()) + bets);		numRaises = gi.getNumRaises();		button = gi.getButton();		gID = gi.getID();      la = pi.lastAction();		lab = (int)pi.getLastBetsToCall();		betRatio = pi.betRatio();		pot = gi.getPot();		betsize = gi.getBetSize();		board = gi.getBoard();	}	public Context(String s) {		if (s == null) return; 		StringTokenizer st = new StringTokenizer(s, "/");		action = Integer.decode(st.nextToken()).intValue();		gID = Integer.decode(st.nextToken()).intValue();		bets = Integer.decode(st.nextToken()).intValue();		committed = Integer.decode(st.nextToken()).intValue();		inhand = (Integer.decode(st.nextToken()).intValue()) == 1;				stage = Integer.decode(st.nextToken()).intValue();		potodds = Double.valueOf(st.nextToken()).doubleValue();		np = Integer.decode(st.nextToken()).intValue();		nap = Integer.decode(st.nextToken()).intValue();		nup = Integer.decode(st.nextToken()).intValue();		position = Integer.decode(st.nextToken()).intValue();		button = Integer.decode(st.nextToken()).intValue();		la = Integer.decode(st.nextToken()).intValue();		lab = Integer.decode(st.nextToken()).intValue();		betRatio = Double.valueOf(st.nextToken()).doubleValue();		hs = Double.valueOf(st.nextToken()).doubleValue();		ppot = Double.valueOf(st.nextToken()).doubleValue();		board = new Hand(st.nextToken().trim());		hnd = new Hand(st.nextToken().trim());	}	public void setGameContext(int pot, int betsize, int id) {		this.gID = id;		this.pot = pot;		this.betsize = betsize;	}			public int getMinBet() {		return (stage >= Holdem.TURN ? betsize/2 : betsize);	}			public void setActionContext(int action, double bets, boolean committed, int stage, double potodds, int numRaises) {		this.action = action;		this.bets = bets;		this.committed = (committed?1:0);		this.stage = stage;		this.potodds = potodds;		this.numRaises = numRaises;	}		public void setNumRaises(int nr) {		this.numRaises = nr;	}		public void setBetSize(int bs) {		this.betsize = bs;	}	public void setPotSize(int ps) {		this.pot = ps;	}	public void setInHand(boolean ih) {		this.inhand = ih;	}	public void setSawCards(boolean sc) {		this.sawCards = sc;	}		public boolean getSawCards() { return sawCards; }	public void setPlayerContext(int numPlayers, int numActivePlayers, 							int numUnactedPlayers, int pos, boolean we_are_in_hand) {		np = numPlayers;		nap = numActivePlayers;		nup = numUnactedPlayers;		position = pos;		inhand = we_are_in_hand;	}	public void setHistoryContext(int lastAction, int lastBetsToCall, double betRatio) {		la = lastAction;		lab = lastBetsToCall;		this.betRatio = betRatio;	}	public void setBoardContext(Hand board) {		this.board = new Hand(board);	}	public void setHandContext(Hand h, double hs, double ppot) {		this.hnd = h;		this.hs = hs;		this.ppot = ppot;	}	public void setAction(int a) { action = a; }	public int getAction() { return action; }	public double getBetsToCall() { return bets; }	public boolean getCommitted() { return committed==1; }	public int getStage() { return stage; }	public int getNumPlayers() { return np; }	public int getNumActivePlayers() { return nap; }	public int getNumUnactedPlayers() { return nup; }	public int getPosition() { return position; }	public int getLastAction() { return la; }	public int getLastBetsToCall() { return lab; }	public boolean getInHand() { return inhand; }	public double getPotOdds() { return potodds; }	public double getBetRatio() { return betRatio; }	public double getHandStrength() { return hs; }	public double getHandPotential() { return ppot; }	public Hand getBoard() { return board; }	public Hand getHand() { return hnd; }		public int getNumRaises() { return numRaises; }	public int getPotSize() { return pot; }	public int getBetSize() { return betsize; }	public int getButton() { return button; }	public int getLastActionCode() {		return getLastActionCode(la, lab);	}		public static int getLastActionCode(int last_action, int lastbets) {	    int lac = -1;	    if (last_action == 1 && lastbets == 0) lac = 0;	    else if (last_action == 1 && lastbets > 0) lac = 1;	    else if (last_action == 2 && lastbets == 0) lac = 2; 	    else if (last_action == 2 && lastbets > 0) lac = 3;	    return lac;	} 	public String toString() {		char c = '/';		StringBuffer s = new StringBuffer();    	s.append(""+action+c+ gID+c+ (int)bets+c+ committed+c+ 						(inhand?1:0)+c+ stage+c+ round(potodds,3)+c);		s.append(""+np+c+ nap+c+ nup+c+ position+c+button+c);   	s.append(""+la+c+ lab+ c+round(betRatio,3)+c+ 							round(hs,3)+c+ round(ppot,3)+c+" ");		s.append(board.toString()+c+" "+hnd+"\n");		return s.toString();	}   /**     * append context data to the given file     * @param file the name of the file to log to.     */    public void saveToFile(String file) {		try {			RandomAccessFile f = new RandomAccessFile(file,"rw");	        f.seek(f.length());	        f.writeBytes(this.toString());	        f.close();		} catch (IOException ie) { ie.printStackTrace(); }    }	private double round(double f, int precision) {	    double n = 1;	    for (int i=0;i<precision;i++) n*=10;	    return java.lang.Math.round(f*n)/n;	}	public int getNumSuits() {		boolean h = false;		boolean d = false;		boolean c = false;		boolean s = false;		for (int i=1;i<=board.size();i++) {			if (board.getCard(i).getSuit() == Card.HEARTS) h = true;			else if (board.getCard(i).getSuit() == Card.DIAMONDS) d = true;			else if (board.getCard(i).getSuit() == Card.CLUBS) c = true;			else if (board.getCard(i).getSuit() == Card.SPADES) s = true;			}		int ns = 0;		if (h) ns++;		if (c) ns++;		if (s) ns++;		if (d) ns++;		return ns;	}	public boolean flushPossible(int nc) {		int n,i;		if (board == null) return false;		for (i=1,n=0;i<=board.size() && i < nc;i++)			if (board.getCard(i).getSuit() == Card.HEARTS) n++;		if (n>3) return true;		for (i=1,n=0;i<=board.size() && i < nc;i++)			if (board.getCard(i).getSuit() == Card.DIAMONDS) n++;		if (n>3) return true;		for (i=1,n=0;i<=board.size() && i < nc;i++)			if (board.getCard(i).getSuit() == Card.SPADES) n++;		if (n>3) return true;		for (i=1,n=0;i<=board.size() && i < nc;i++)			if (board.getCard(i).getSuit() == Card.CLUBS) n++;		if (n>3) return true;		return false;	}		public boolean aceOnBoard() {		if (board == null) return false;		for (int i=1,n=0;i<=board.size();i++) 			if (board.getCard(i).getRank() == Card.ACE) return true;		return false;	}		public boolean kingOnBoard() {		if (board == null) return false;		for (int i=1,n=0;i<=board.size();i++) 			if (board.getCard(i).getRank() == Card.KING) return true;		return false;	}		public double highCards(int nc) {		double c = 0;		if (board == null) return 0;		for (int i=1,n=0;i<=board.size() && i < nc;i++) 			if (board.getCard(i).getRank() == Card.ACE || board.getCard(i).getRank() == Card.KING				|| board.getCard(i).getRank() == Card.QUEEN) 				c++;		if (nc < board.size()) return c/(double)nc;		return c/(double)board.size();	}	public int getCommittment() {		if (committed == 1) {			return la * (lab + 1);		} else return 0;	}	public int getPositionCode() {		if (getNumUnactedPlayers() == getNumActivePlayers()) return 0;		if (getNumUnactedPlayers() == 1) return 2;		return 1;	}}