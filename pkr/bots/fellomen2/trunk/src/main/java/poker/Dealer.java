/***************************************************************************   Copyright (c) 2000:         University of Alberta,         Deptartment of Computing Science         Computer Poker Research Group         See "Liscence.txt"***************************************************************************/package poker;import poker.util.*;import java.util.Vector;import java.util.Hashtable;/** * This is a standard dealer class for managing a Holdem game. * * Does not (yet) handle 'all-In' situations * * @author  Aaron Davidson * @version 1.1.2 */public class Dealer implements Runnable {	private HandEvaluator he = new HandEvaluator();	private boolean THREADED = false;	protected Reporter 	r;	protected GameInfo  	gInfo;	protected Deck      	gDeck;	protected Hashtable 	bettors;	protected Hand[]     holes;	private int				gAction, gCode;	private int 			toAct;	/** 	 * Constructor.	 */	public Dealer() { 		init();		gDeck = new Deck(); 	}	/** 	 * Constructor w/ random seed.	 * @param seed the random seed to use for deck shuffling	 */	public Dealer(int seed) { 		init();		gDeck = new Deck(seed); 	}		public void setThreaded(boolean th) {		THREADED = th;		he.setThreadSafe(th);	}		public void setSeed(int seed) {		gDeck = new Deck(seed);			}	private void init() {		holes = new Hand[Holdem.MAX_PLAYERS];		bettors = new Hashtable(Holdem.MAX_PLAYERS);		gInfo = new GameInfo();		r = gInfo.getReporter();		setThreaded(THREADED);	}	/**	 * Add a player to the next game (if there is room)	 * @param name  the name of the player to add	 * @param b	the actual player which will make decisions	 * @return	true if player is added, flase if not	 */	public boolean addPlayer(String name, Player b) {		if (gInfo.getNumPlayers() == Holdem.MAX_PLAYERS-1 || bettors.containsKey(name)) return false;		bettors.put(name,b);		return gInfo.addPlayer(name, gInfo.LOG_DIR+name.toLowerCase()+".dat");	}		/**	 * Add a player to the next game (if there is room)	 * @param name  the name of the player to add	 * @param b	the actual player which will make decisions	 * @return	true if player is added, flase if not	 */	public boolean insertPlayer(String name, Player b, int pos) {		if (gInfo.getNumPlayers() == Holdem.MAX_PLAYERS-1 || bettors.containsKey(name)) return false;		bettors.put(name,b);		return gInfo.insertPlayer(name, gInfo.LOG_DIR+name.toLowerCase()+".dat", pos);	}	/**	 * Remove a player from the next game.	 * @param name the name of the player	 * @return true if removed, false if not	 */	public boolean removePlayer(String name) {		if (gInfo.getNumPlayers() == 0 || !bettors.containsKey(name)) return false;		bettors.remove(name);		return gInfo.removePlayer(name);	}	/**	 * Remove all players from the next game.	 */	public void removeAllPlayers() {		bettors.clear();		gInfo.removeAllPlayers();	}	/**	 * Obtain the game info for the current game.	 */	public GameInfo getGameInfo() { return gInfo; }	/**	 * Check if a player with a given name is already in the game.	 * @param name the player name to check	 * @return true if the player is in the game	 */	public boolean inGame(String name) {		return bettors.containsKey(name);	}	// list players & bankrolls	public void printTable() {		println("");		println("\n--- NEW GAME --- " + gInfo.getID() + " ---");		for (int i=0;i<gInfo.getNumPlayers();i++) 			println((i==gInfo.getButton() ? ("B> ") : (" > ")) + pad(gInfo.getPlayerName(i), 14) + " " + gInfo.getPlayerInfo(i).getBankRoll() );		println("-----------------------");	}					public void dealCards() {		gDeck.shuffle();		gDeck.shuffle();		gDeck.shuffle();							// deal cards to each player  		for (int i=0;i<gInfo.getNumPlayers();i++) {			Hand h = new Hand();			h.addCard(gDeck.dealCard());			h.addCard(gDeck.dealCard());			holes[i] = h;			((Player)bettors.get(gInfo.getPlayerName(i))).newGame(gInfo, h.getCard(1), h.getCard(2), i);		}	}	public Card nextBoardCard() {		return gDeck.dealCard();	}	/**	 * Play one game of poker with the current set of players	 */	public void playGame() {		// check if not enough players		if (gInfo.getNumPlayers() < 2) return; 		int i;				gInfo.startNewGame();			printTable();	/*	println("");		println("--- NEW GAME --- " + gInfo.getID() + " ---");			for (i=0;i<gInfo.getNumPlayers();i++) 			println(" > " + pad(gInfo.getPlayerName(i), 14) + " $" + gInfo.getPlayerInfo(i).getBankRoll() );		// list players & bankrolls		println("-----------------------");*/			dealCards();		toAct = gInfo.getNumActivePlayers();		// start preflop betting round		updatePlayers(GameInfo.U_STAGE, Holdem.PREFLOP);		gInfo.advanceCurrentPlayer();		// small blind		gInfo.smallBlind();		updatePlayers(GameInfo.U_SBLIND, gInfo.getCurrentPlayerPosition());		println(gInfo.getCurrentPlayerName() + " blinds $" + (gInfo.getLowBet() / 2));		gInfo.advanceCurrentPlayer();		// big blind		gInfo.bigBlind();		updatePlayers(GameInfo.U_BBLIND, gInfo.getCurrentPlayerPosition());		println(gInfo.getCurrentPlayerName() + " blinds $" + gInfo.getLowBet());		gInfo.advanceCurrentPlayer();		if (betLoop()) return;		// flop		gInfo.flop(nextBoardCard(),nextBoardCard(),nextBoardCard());	  		println("************************************");		println(" FLOP: " + gInfo.getBoard().toString() + "          \t$" + gInfo.getPot());		println("************************************");		updatePlayers(GameInfo.U_STAGE, Holdem.FLOP);		if (betLoop()) return;		// turn			gInfo.turn(nextBoardCard());	  		println("************************************");		println(" TURN: " + gInfo.getBoard().toString() + "       \t$" + gInfo.getPot());		println("************************************");		updatePlayers(GameInfo.U_STAGE, Holdem.TURN);		if (betLoop()) return;		// river		gInfo.river(nextBoardCard());	  		println("************************************");		println(" RIVR: " + gInfo.getBoard().toString() + "    \t$" + gInfo.getPot());		println("************************************");		updatePlayers(GameInfo.U_STAGE, Holdem.RIVER);		if (betLoop()) return;		showdown();		gInfo.gameOver();				updatePlayers(GameInfo.U_GAME_OVER, 0);		for (int j=0;j<gInfo.getNumPlayers();j++)			gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));		gInfo.logGame();	}	public int getToAct() { return toAct; }		protected boolean betLoop() {		toAct = gInfo.getNumActivePlayers();		//if (!gInfo.activePlayer(gInfo.getButton())) gInfo.advanceCurrentPlayer();				// betting loop		while (toAct > 0) {			switch (((Player)bettors.get(gInfo.getCurrentPlayerName())).action()) {				case Holdem.FOLD: 					toAct--;					println(gInfo.getCurrentPlayerName() + " folds");					boolean gameover = gInfo.fold();					updatePlayers(GameInfo.U_FOLD, gInfo.getCurrentPlayerPosition());					if (gameover) {						gInfo.advanceCurrentPlayer();							gInfo.getCurrentPlayerInfo().win(gInfo.getPot());						gInfo.addWinner(gInfo.getCurrentPlayerName());						println(gInfo.getCurrentPlayerName() + " wins $" + gInfo.getPot());						gInfo.gameOver();						updatePlayers(GameInfo.U_GAME_OVER, 0);						for (int j=0;j<gInfo.getNumPlayers();j++)							gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));						gInfo.logGame();						return true;					}					break;				case Holdem.CALL:					toAct--;					doCall();					break;				case Holdem.RAISE: 					// handle maximum raise error by calling instead					if (gInfo.getNumRaises() >= Holdem.MAX_RAISES) {						toAct--;						doCall();					} else {						toAct = gInfo.getNumActivePlayers()-1;						doRaise();					}					break;				default: break;			}			gInfo.advanceCurrentPlayer();		}		toAct = gInfo.getNumActivePlayers();		return false;	}	private void doCall() {		int amnt = gInfo.call();		if (amnt == 0) {			println(gInfo.getCurrentPlayerName() + " checks");			updatePlayers(GameInfo.U_CHECK, gInfo.getCurrentPlayerPosition());			}  else {			println(gInfo.getCurrentPlayerName() + " calls $" + amnt);			updatePlayers(GameInfo.U_CALL, gInfo.getCurrentPlayerPosition());		}	}		private void doRaise() {			if (gInfo.raise()) {			println(gInfo.getCurrentPlayerName() + " bets $" + gInfo.getBetSize());			updatePlayers(GameInfo.U_BET, gInfo.getCurrentPlayerPosition());								} else {			println(gInfo.getCurrentPlayerName() + " raises $" + gInfo.getBetSize());			updatePlayers(GameInfo.U_RAISE, gInfo.getCurrentPlayerPosition());		}	}			protected void showdown() {		int i,j;		int best,ties=0;				j = best = gInfo.nextActivePlayer(-1);		for (i=0;i<gInfo.getNumActivePlayers();i++, j=gInfo.nextActivePlayer(j)) {			gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));			println(gInfo.getPlayerName(j) + ": " + holes[j].toString());			updatePlayers(GameInfo.U_SHOWDOWN, j);			for (int k=0;k<5;k++)				holes[j].addCard(gInfo.getBoardCard(k));				if (best != j) {				int v = he.compareHands(holes[j],holes[best]);				if (v == 1) {					best = j;					ties = 0;				} else if (v == 0) { // equally strong hands					ties++;				}			}		}		if (ties == 0) {			gInfo.getPlayerInfo(best).win(gInfo.getPot());			gInfo.addWinner(gInfo.getPlayerName(best));			println(gInfo.getPlayerName(best) + " wins $" + gInfo.getPot() + " with " + he.nameHand(holes[best]));		} else {			// divide pot amongst winners			int excess = gInfo.getPot() - (ties+1)*(gInfo.getPot()/(ties+1));				j = gInfo.nextActivePlayer(gInfo.getButton());						for (i=0; i<gInfo.getNumActivePlayers(); i++, j=gInfo.nextActivePlayer(j)) {				if (he.compareHands(holes[j],holes[best]) == 0) {					int e = (excess-- > 0 ? 1 : 0);					int ps = e + gInfo.getPot()/(ties+1);					gInfo.addWinner(gInfo.getPlayerName(j));					gInfo.getPlayerInfo(j).win(ps);					println(gInfo.getPlayerName(j) + " wins $" + ps + " with " + he.nameHand(holes[best]));				}			}		}				//println("High: " + he.nameHand(holes[best]));	}	public void run() {		String str = Thread.currentThread().getName();		((Player)bettors.get(str)).update(gAction, gCode);	}	protected void updatePlayers(int action, int code) {						if (action == GameInfo.U_GAME_OVER || (!THREADED)) {			for (int i=0;i<gInfo.getNumPlayers();i++) {				((Player)bettors.get(gInfo.getPlayerName(i))).update(action, code);			}		} else { 			Thread[] t = new Thread[gInfo.getNumPlayers()];			gAction	= action;			gCode = code;			for (int i=0;i<gInfo.getNumPlayers();i++) {				t[i] = new Thread(this, gInfo.getPlayerName(i));				t[i].start();			}			for (int i=0;i<gInfo.getNumPlayers();i++) {				try {t[i].join();}				catch (InterruptedException ie) {}			}		}	}	protected void println(String s) {		r.report(s);	}		protected void print(String s) {		r.reportb(s);	}	public static String pad(String s, int size) {    	if (s.length() < size) return pad(s+" ", size);    	return s;    }}