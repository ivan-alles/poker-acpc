/* Copyright 2010-2012 Ivan Alles.
   Licensed under the MIT License (see file LICENSE). */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using NUnit.Framework;
using ai.pkr.metagame;
using System.IO;
using System.Reflection;
using System.Xml;
using ai.lib.utils;
using System.Globalization;
using System.Text.RegularExpressions;
using ai.lib.algorithms;
using ai.pkr.metastrategy;


namespace ai.pkr.theory.exploitation
{
    [TestFixture]
    public class Exploitation
    {
        #region Tests

        [Test]
        public void Test_GenerateFiles()
        {
            XmlStrategyHelper strHelper = new XmlStrategyHelper();

            string dataDir = Props.Global.Get("bds.DataDir");
            string workingDir = Directory.GetCurrentDirectory() + @"..\..\..\..\";

            GameDefinition gd = XmlSerializerExt.Deserialize<GameDefinition>(
                Path.Combine(dataDir, "ai.pkr.metastrategy.kuhn.gamedef.1.xml"));

            bool[] normSuits = new bool[] {false, true};

            int pos = 0;
            strHelper.HeroPosition = pos;

            strHelper.StrategyFiles = new string[] { null, Path.Combine(workingDir, "kuhn-s-1-eq.xml") };
            strHelper.LoadStrategies();
            Sbr brEq = FindBestResponse(strHelper, pos, gd, null);

            Assert.AreEqual(-1.0 / 18, brEq.PlayerTrees[pos].Value, 0.00000001);
            Assert.AreEqual(1.0, brEq.PlayerTrees[pos].Probab, 0.00000001);

            using (TextWriter tw = new StreamWriter(Path.Combine(workingDir, "str-eq-p1.gv")))
            {
                Sbr.Visualizer vis = new VisStr{ Output = tw };
                SetVisAttributes(vis);
                vis.NodeAttributes.fontsize = 10;
                vis.ShowExpr.Add(new ExprFormatter("s[d].Node.Id", "id:{1}"));
                vis.ShowExpr.Add(new ExprFormatter("s[d].Node.StrategicProbab", "\\nsp:{1:0.###}        "));
                vis.Walk(brEq.PlayerTrees[1-pos]);
            }

            using (TextWriter tw = new StreamWriter(Path.Combine(workingDir, "br-eq-p0.gv")))
            {
                VisBr visBr = new VisBr { Output = tw };
                // visBr.SetDefaultAttrbutes(brEq, perspective);
                SetVisAttributes(visBr);
                visBr.ShowExpr.Add(new ExprFormatter("s[d].Node.Id", "id:{1}"));
                visBr.ShowExpr.Add(new ExprFormatter("-s[d].Node.Value",  "\\nv:{1:0.0000}    "));
                visBr.Walk(brEq.PlayerTrees[pos]);
            }

            strHelper.StrategyFiles = new string[] { null, Path.Combine(workingDir, "kuhn-s-1-qf-.xml") };
            strHelper.LoadStrategies();
            brEq = FindBestResponse(strHelper, pos, gd, null);

            Assert.AreEqual(1.0, brEq.PlayerTrees[pos].Probab, 0.00000001);

            using (TextWriter tw = new StreamWriter(Path.Combine(workingDir, "br-qf--p0.gv")))
            {
                VisBr visBr = new VisBrNoEq { Output = tw };
                // visBr.SetDefaultAttrbutes(brEq, perspective);
                SetVisAttributes(visBr);
                visBr.ShowExpr.Add(new ExprFormatter("s[d].Node.Id", "id:{1}"));
                visBr.ShowExpr.Add(new ExprFormatter("-s[d].Node.Value",  "\\nv:{1:0.0000}    "));
                visBr.Walk(brEq.PlayerTrees[pos]);
            }

            strHelper.StrategyFiles = new string[] { null, Path.Combine(workingDir, "kuhn-s-1-qf+.xml") };
            strHelper.LoadStrategies();
            brEq = FindBestResponse(strHelper, pos, gd, null);

            Assert.AreEqual(1.0, brEq.PlayerTrees[pos].Probab, 0.00000001);

            using (TextWriter tw = new StreamWriter(Path.Combine(workingDir, "br-qf+-p0.gv")))
            {
                VisBr visBr = new VisBrNoEq { Output = tw };
                // visBr.SetDefaultAttrbutes(brEq, perspective);
                SetVisAttributes(visBr);
                visBr.ShowExpr.Add(new ExprFormatter("s[d].Node.Id", "id:{1}"));
                visBr.ShowExpr.Add(new ExprFormatter("-s[d].Node.Value", "\\nv:{1:0.0000}    "));
                visBr.Walk(brEq.PlayerTrees[pos]);
            }
        }

        private void SetVisAttributes(Sbr.Visualizer vis)
        {
            vis.GraphAttributes.Map["fontname"] = "arial";
            vis.GraphAttributes.fontsize = 10;
            vis.NodeAttributes.fontsize = 9;
            vis.EdgeAttributes.fontsize = 10;
        }

        #endregion


        #region Implementation

        class VisStr : Sbr.Visualizer
        {
            protected override void CustomizeNodeAttributes(Sbr.TreeNode tree, Sbr.TreeNode node, List<Context> stack, int depth, ai.lib.algorithms.tree.VisTree<Sbr.TreeNode, Sbr.TreeNode, int, Context>.NodeAttributeMap attr)
            {
                base.CustomizeNodeAttributes(tree, node, stack, depth, attr);
                if (!node.Action.HasPlayerActed(1))
                {
                    attr.label = string.Format("id:{0}", node.Id);
                }
                else if (node.Id == 18 || node.Id == 19)
                {
                    attr.penwidth = 3;
                }
            }
        }

        class VisBr : Sbr.Visualizer
        {
            public VisBr()
            {
                MergePrivateDeals = true;
            }

            protected override bool OnNodeBeginFunc(Sbr.TreeNode tree, Sbr.TreeNode node, List<Context> stack, int depth)
            {
                bool result = base.OnNodeBeginFunc(tree, node, stack, depth);
                if (node.Id == 14 || node.Id == 15 || node.Id == 19 || node.Id == 20)
                    return false;
                return result;
            }

            protected override void CustomizeNodeAttributes(Sbr.TreeNode tree, Sbr.TreeNode node, List<Context> stack, int depth, ai.lib.algorithms.tree.VisTree<Sbr.TreeNode, Sbr.TreeNode, int, Context>.NodeAttributeMap attr)
            {
                base.CustomizeNodeAttributes(tree, node, stack, depth, attr);
                //attr.Map["labeldistance"] = "30";
                if (node.Id == 12)
                {
                    attr.label += string.Format("\\np1 can't have Q    \\n=> hide rest    ", node.Id);
                }
                else if(node.Id == 9 || node.Id == 10 || node.Id == 29 || node.Id == 30)
                {
                    attr.penwidth = 3;
                }
                if (node.Id == 13 || node.Id == 18)
                {
                    attr.style = "invis";
                }
            }

            protected override void CustomizeEdgeAttributes(Sbr.TreeNode tree, Sbr.TreeNode node, Sbr.TreeNode parent, List<Context> stack, int depth, ai.lib.algorithms.tree.VisTree<Sbr.TreeNode, Sbr.TreeNode, int, Context>.EdgeAttributeMap attr)
            {
                base.CustomizeEdgeAttributes(tree, node, parent, stack, depth, attr);
                if(!string.IsNullOrEmpty(attr.label))
                {
                    attr.label = attr.label + "          ";
                }
                if(node.Id == 3 || node.Id == 23)
                {
                    PrintEdgeText(node, attr, "=", "GREEN");
                }
                if (node.Id == 8 || node.Id == 28)
                {
                    PrintEdgeText(node, attr, " ", "GREEN");
                }
                if (node.Id == 13 || node.Id == 18)
                {
                    attr.style = "invis";
                }
            }

            protected void PrintEdgeText(Sbr.TreeNode node, EdgeAttributeMap attr, string sign, string color)
            {
                attr.label = String.Format("<{0} <BR/>  <FONT FACE = \"ARIAL\" COLOR=\"{2}\" POINT-SIZE=\"40\">{1}</FONT>>", node.Action, sign, color);
            }
        }

        class VisBrNoEq: VisBr
        {
            protected override void CustomizeNodeAttributes(Sbr.TreeNode tree, Sbr.TreeNode node, List<Sbr.Visualizer.Context> stack, int depth, ai.lib.algorithms.tree.VisTree<Sbr.TreeNode, Sbr.TreeNode, int, Sbr.Visualizer.Context>.NodeAttributeMap attr)
            {
                base.CustomizeNodeAttributes(tree, node, stack, depth, attr);
                if (node.Id == 0)
                {
                    PrintChangedValue(node, attr, 0.0556);
                }
                if (node.Id == 1 || node.Id == 2 || node.Id == 8)
                {
                    PrintChangedValue(node, attr, 0.3333);
                }
                if (node.Id == 9)
                {
                    PrintChangedValue(node, attr, -0.1111);
                }
                if (node.Id == 10)
                {
                    PrintChangedValue(node, attr, .4444);
                }
                if (node.Id == 21 || node.Id == 22 || node.Id == 28)
                {
                    PrintChangedValue(node, attr, -0.3889);
                }
                if (node.Id == 29)
                {
                    PrintChangedValue(node, attr, -0.2778);
                } 
                if (node.Id == 30)
                {
                    PrintChangedValue(node, attr, -0.1111);
                }
                if (node.Id == 9 || node.Id == 10 || node.Id == 29 || node.Id == 30)
                {
                    attr.penwidth = 4;
                }
            }

            private void PrintChangedValue(Sbr.TreeNode node, NodeAttributeMap attr, double eqValue)
            {
                double delta = (-node.Value) - eqValue;
                string color = delta >= 0 ? "#006600" : "#BB0000";
                attr.label = String.Format("< <FONT POINT-SIZE=\"10\" FACE=\"ARIAL\">id:{0}<BR/>v:{1:0.0000}<BR/><FONT COLOR=\"{2}\" >Δ:{3:0.0000}</FONT></FONT> >",
                                           node.Id, -node.Value, color, delta);
            }

            protected void PrintEdgeText(Sbr.TreeNode node, Sbr.TreeNode parent, EdgeAttributeMap attr)
            {
                string sign = parent.Children[0].Value < parent.Children[1].Value ? "&gt;" : "&lt;";
                string color = sign == "&gt;" ? "RED" : "GREEN";
                PrintEdgeText(node, attr, sign, color);
            }

            protected override void CustomizeEdgeAttributes(Sbr.TreeNode tree, Sbr.TreeNode node, Sbr.TreeNode parent, List<Context> stack, int depth, ai.lib.algorithms.tree.VisTree<Sbr.TreeNode, Sbr.TreeNode, int, Context>.EdgeAttributeMap attr)
            {
                base.CustomizeEdgeAttributes(tree, node, parent, stack, depth, attr);
                if (node.Id == 3)
                {
                    PrintEdgeText(node, parent, attr);
                }
                if (node.Id == 23)
                {
                    PrintEdgeText(node, parent, attr);
                }
            }
        }

        /// <summary>
        /// This code is copypasted from StaticBestResponse_Test.
        /// </summary>
        public abstract class StrategyHelper
        {
            public int HeroPosition;

            public string[] StrategyFiles;

            public abstract void LoadStrategies();

            public abstract void SetProbabilityOfOppAction();

            public GameDefinition GameDef;

            protected void AddStrategicProbability(int id, double probability)
            {
                while (OppStrategy.Count <= id)
                {
                    OppStrategy.Add(0);
                }
                OppStrategy[id] = probability;
        }

            // Flattened opponent strategy
            public List<double> OppStrategy = new List<double>();

        }

        /// <summary>
        /// This code is copypasted from StaticBestResponse_Test.
        /// </summary>
        public class XmlStrategyHelper : StrategyHelper
        {
            XmlDocument[] Strategies
            {
                set;
                get;
            }

            public override void LoadStrategies()
            {
                Strategies = new XmlDocument[] { new XmlDocument(), new XmlDocument() };
                if (StrategyFiles[0] != null) Strategies[0].Load(StrategyFiles[0]);
                if (StrategyFiles[1] != null) Strategies[1].Load(StrategyFiles[1]);
            }

            public override void SetProbabilityOfOppAction()
            {
                OppStrategy.Clear();
                SetProbability(Strategies[1 - HeroPosition].DocumentElement, 1.0);
            }

            private void SetProbability(XmlElement strategyNode, double absoluteProbability)
            {
                int pos = 1 - HeroPosition;

                double localStrProbab = 1;
                int xmlId = int.Parse(strategyNode.GetAttribute("id"));
                if (strategyNode.HasAttribute("p"))
                {
                    int xmlPos = int.Parse(strategyNode.GetAttribute("p"));
                    if (xmlPos == pos &&
                        (strategyNode.Name == "r" || strategyNode.Name == "c" || strategyNode.Name == "f"))
                {
                    if (!strategyNode.HasAttribute("probab"))
                    {
                        // No probability specified - take (1 - sum-other-siblings) 
                        XmlElement parent = (XmlElement)strategyNode.ParentNode;
                        double sumSiblings = 0;
                        foreach(XmlNode child in parent.ChildNodes)
                        {
                            // Skip this node
                            if (object.ReferenceEquals(child, strategyNode))
                                continue; 
                            // Id is useful for debugging.
                            string id = ((XmlElement)child).GetAttribute("id"); 
                            string probabText = ((XmlElement) child).GetAttribute("probab");
                            sumSiblings += GetLocalStrProbab(probabText);
                        }
                        localStrProbab = 1 - sumSiblings;
                    }
                    else
                    {
                        string probabText = strategyNode.GetAttribute("probab");
                        localStrProbab = GetLocalStrProbab(probabText);
                    }
                        AddStrategicProbability(xmlId, localStrProbab * absoluteProbability);
                    }
                }


                foreach (XmlNode strategyChild in strategyNode.ChildNodes)
                {
                    if (!(strategyChild is XmlElement))
                        continue;
                    SetProbability((XmlElement)strategyChild, localStrProbab * absoluteProbability);
                }
            }

            protected virtual double GetLocalStrProbab(string probabText)
            {
                double localStrProbab = double.Parse(probabText, CultureInfo.InvariantCulture);
                return localStrProbab;
            }
        }

        private Sbr FindBestResponse(StrategyHelper strHelper, int pos, GameDefinition gd,
            Sbr.CreateRootGenNodeDelegate createRootGenNodeDelegate)
        {
            Sbr br = new Sbr();

            br.GameDef = gd;
            br.HeroPosition = pos;

            if (createRootGenNodeDelegate != null)
            {
                br.CreateRootGenNode = createRootGenNodeDelegate;
            }

            strHelper.SetProbabilityOfOppAction();
            br.SetOppStrategy(1 - pos, strHelper.OppStrategy.ToArray());
            br.Calculate();

            return br;
        }

        #endregion
    }
}
